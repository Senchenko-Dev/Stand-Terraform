- name: Update SRC local files
  block:

    - name: trigger revert check
      block:

        - name: touch trigger
          file:
            path: "{{ update_status_files.dir }}/.trigger_stop_update"
            state: touch
          become: true
          when: is_recovery_test_mode and trigger_stop08m

        - name: trigger stop updated
          include_role:
            name: common
            tasks_from: trigger_stop_update

      when: inventory_hostname == 'master'

    - name: create bin backup module to remote hosts
      copy:
        src: "{{ local_distr_path }}/pg_backup/manage_backup.bin"
        dest: "{{ manage_backup_bin }}/{{ pg_current_version.split('.').0 }}_manage_backup.bin"
        owner: root
        group: root
        mode: 0751

    - name: copy templates sh scripts for start-stop backup
      template:
        src: "{{ item.source }}"
        dest: "{{ manage_backup_bin }}/original_scripts_{{ item.dest.split('/')[-1] }}"
        owner: root
        group: root
        mode: 0751
      with_items:
        - { source: 'pg_se_archlogs.sh.j2', dest: '{{ path_to_pg_se_archlogs_sh_file }}' }
        - { source: 'manage_backup.sh.j2',  dest: '{{ path_to_manage_backup_sh_file }}' }
      vars:
        src_bin_version: "{{ pg_current_version.split('.').0 }}"

    - debug: msg="{{ update_error_types_breakpoint_msg }}"
      when: is_recovery_test_mode and src_error_um01m and inventory_hostname == 'master'
    - debug: msg="{{ update_error_types_breakpoint_msg }}"
      when: is_recovery_test_mode and src_error_um01r and inventory_hostname == 'replica'

  rescue:

    - name: replica updated with error
      set_fact:
        update_errors: "{{ update_errors|combine(data, recursive=True) }}"
        cacheable: yes
      vars:
        data:
          aggregate: true
          hosts:
            replica: true
          components:
            src: true
          types:
            src:
              main: true
      run_once: true
      when: inventory_hostname == 'replica'

    - name: master updated with error
      set_fact:
        update_errors: "{{ update_errors|combine(data, recursive=True) }}"
        cacheable: yes
      vars:
        data:
          aggregate: true
          hosts:
            master: true
          components:
            src: true
          types:
            src:
              main: true
      run_once: true
      when: inventory_hostname == 'master'

  become: true
  when: "inventory_hostname != 'etcd' \
         and SRC \
         and is_src_exists \
         and not is_src_exists_and_not_correct"