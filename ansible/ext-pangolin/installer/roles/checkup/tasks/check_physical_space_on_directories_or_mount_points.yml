- name: Check physical space on directories/mount points
  block:

    - set_fact:
        pgdata_string: "/{{ PGDATA.split('/')[1] }}"
        pgbackup_string: "/{{ PGBACKUP.split('/')[1] }}"

    - name: check if {{ pgdata_string }} exists
      stat:
        path: "{{ pgdata_string }}"
      register: pgdata_exists
      become: true
      become_user: postgres

    - name: check if {{ pgbackup_string }} exists
      stat:
        path: "{{ pgbackup_string }}"
      register: pgbackup_exists
      become: true
      become_user: postgres

    - name: check if {{ REMOTE_TMP }} exists
      stat:
        path: "{{ REMOTE_TMP }}"
      register: remote_tmp_exists
      become: true
      become_user: postgres

    - name: get the name of the mount point for {{ pgbackup_string }}
      shell: "df {{ pgbackup_string }}"
      register: pgbackup_mp
      when: pgbackup_exists.stat.exists

    - name: get free space in the directory {{ pgdata_string }}
      shell: "df --output=avail {{ pgdata_string }} | tail -1"
      register: pgdata_mp_free
      become: true
      become_user: postgres
      when: pgdata_exists.stat.exists

    - name: get free space in the directory {{ pgbackup_string }}
      shell: "df --output=avail {{ pgbackup_string }} | tail -1"
      register: pgbackup_mp_free
      become: true
      become_user: postgres
      when: pgbackup_exists.stat.exists

    - name: get free space in the directory {{ REMOTE_TMP }}
      shell: "df --output=avail {{ REMOTE_TMP }} | tail -1"
      register: remote_tmp_mp_free
      become: true
      become_user: postgres
      when: remote_tmp_exists.stat.exists

    - name: pgdata_mp_free in Gb
      set_fact:
        pgdata_mp_free_mb: "{{ (pgdata_mp_free.stdout | int / 1024 ) | int }}"
        pgdata_mp_free_gb: "{{ (pgdata_mp_free.stdout | int / 1024 / 1024) | int }}"
      when: pgdata_exists.stat.exists

    - name: pgbackup_mp_free in Gb
      set_fact:
        pgbackup_mp_free_gb: "{{ (pgbackup_mp_free.stdout | int / 1024 / 1024) | int }}"
      when: pgbackup_exists.stat.exists

    - name: remote_tmp_mp_free in Gb
      set_fact:
        remote_tmp_mp_free_gb: "{{ (remote_tmp_mp_free.stdout | int / 1024 / 1024) | int }}"
      when: remote_tmp_exists.stat.exists

    - name: checking the available space for the {{ REMOTE_TMP }}
      assert:
        that: remote_tmp_mp_free_gb|int >= 1
        fail_msg: "{{ message_installer.fails.disk_size_tmp.format(remote_tmp_mp_free_gb) }}"
        success_msg: "{{ message_installer.info.disk_size_tmp.format(remote_tmp_mp_free_gb) }}"
      when: remote_tmp_exists.stat.exists

    - name: check physical space on directories/mount points for installation
      block:

      - set_fact:
          pglogs_string: "/{{ PGLOGS.split('/')[1] }}"

      - name: check if {{ pglogs_string }} exists
        stat:
          path: "{{ pglogs_string }}"
        register: pglogs_exists
        become: true
        become_user: postgres

      - name: get free space in the directory {{ pglogs_string }}
        shell: "df --output=avail {{ pglogs_string }} | tail -1"
        register: pglogs_mp_free
        become: true
        become_user: postgres
        when: pglogs_exists.stat.exists

      - name: pglogs_mp_free in Gb
        set_fact:
          pglogs_mp_free_gb: "{{ (pglogs_mp_free.stdout | int / 1024 / 1024) | int }}"
        when: pglogs_exists.stat.exists

      - name: checking the available space for the {{ PGDATA }}
        assert:
          that: pgdata_mp_free_gb|int >= min_space_pgdata
          fail_msg: "{{ message_installer.fails.disk_size_pgdata.format(PGDATA, pgdata_mp_free_gb, min_space_pgdata) }}"
          success_msg: "{{ message_installer.info.disk_size_pgdata.format(PGDATA, pgdata_mp_free_gb) }}"
        when: pgdata_exists.stat.exists and min_space_pgdata > 0

      - name: checking the available space for the {{ PGBACKUP }}
        assert:
          that: pgbackup_mp_free_gb|int >= min_space_pgarclogs
          fail_msg: "{{ message_installer.fails.disk_size_pgbackup.format(PGBACKUP, pgbackup_mp_free_gb, min_space_pgarclogs) }}"
          success_msg: "{{ message_installer.info.disk_size_pgbackup.format(PGBACKUP, pgbackup_mp_free_gb) }}"
        when: pgbackup_exists.stat.exists and min_space_pgarclogs > 0

      - name: checking the available space for the {{ PGLOGS }}
        assert:
          that: pglogs_mp_free_gb|int >= min_space_pgerrorlogs
          fail_msg: "{{ message_installer.fails.disk_size_pglogs.format(PGLOGS, pglogs_mp_free_gb, min_space_pgerrorlogs) }}"
          success_msg: "{{ message_installer.info.disk_size_pglogs.format(PGLOGS, pglogs_mp_free_gb) }}"
        when: pglogs_exists.stat.exists and min_space_pgerrorlogs > 0

      - name: create reserve storage of free space
        shell:
          cmd: "dd if=/dev/zero of=/{{ PGDATA.replace('/', ' ').split().0 }}/sos bs=1M count={{ sos_file_size }}"
        when: "pgdata_exists.stat.exists and sos_file_size > 0"
        become: true

      when: action_type == 'install'

    - name: check physical space on directories/mount points for update
      block:

        - name: check that backup folder has 1 GB of free space
          assert:
            that: pgbackup_mp_free_gb|int >= 1
            fail_msg: "{{ scout_control_msgs.fail_space.disk_pgbackup_min.format(pgbackup_mp_free_gb) }}"
            success_msg: "{{ message_installer.info.disk_size_pgbackup.format(PGBACKUP, pgbackup_mp_free_gb) }}"

        - name: check maximum DBMS size for updating
          block:

            - name: get {{ PGDATA.split('/')[1] }} size
              shell: "du -sk /{{ PGDATA.split('/')[1] }} | awk '{print $1}'"
              register: pgdata_size
              become: true
              become_user: postgres
              when: pgdata_exists.stat.exists

            - name: pgdata size in Mb and Gb
              set_fact:
                pgdata_size_mb: "{{ (pgdata_size.stdout_lines.0 | int / 1024) | int }}"
                pgdata_size_gb: "{{ (pgdata_size.stdout_lines.0 | int / 1024 / 1024) | int }}"
              when: pgdata_exists.stat.exists

            - name: adding an error to the scout_error_list_assert if exceeded the maximum DBMS size for updating
              set_fact:
                scout_error_list_assert: "{{ scout_error_list_assert + [item] }}"
              no_log: "{{ nolog }}"
              with_items:
                - "{{ scout_control_msgs.fails.maximum_dbms_size_to_update |\
                      replace('maximum_dbms_size_to_update',maximum_dbms_size_to_update) |\
                      replace('current_dbms_size',pgdata_size_gb) }}"
              when: pgdata_size_gb|int > maximum_dbms_size_to_update|int and maximum_dbms_size_to_update|int > 0

            - name: print message if exceeded the maximum DBMS size for updating
              assert:
                that: pgdata_size_gb|int <= maximum_dbms_size_to_update|int
                fail_msg: "exceeded the maximum DBMS size for updating (pgdata_size_gb = {{ pgdata_size_gb}}, \
                           maximum_dbms_size_to_update = {{ maximum_dbms_size_to_update }})"
              when: maximum_dbms_size_to_update|int > 0

          when: action_type == 'update_major' and ansible_fqdn == current_master

        - name: сheck physical space local_backup_path on directories/mount points
          block:

            - name: calculating the value for local_backup_coefficient
              set_fact:
                calc_local_backup_coefficient: "{{ pgdata_size_mb|int * (local_backup_coefficient|int * 0.01) }}"

            - name: pgdata_size_mb + local_backup_coefficient
              set_fact:
                local_size_backup_mb: "{{ ((pgdata_size_mb | int) + (calc_local_backup_coefficient | int))  | int }}"
              when: pgdata_exists.stat.exists

            - name: get available free space in a folder {{ local_backup_path }}
              block:

                - name: check if {{ local_backup_path }} exists
                  stat:
                    path: "{{ local_backup_path }}"
                  register: local_backup_path_folder

                - name: adding an error to the scout_error_list_assert if local_backup_path is not exists
                  set_fact:
                    scout_error_list_assert: "{{ scout_error_list_assert + [item] }}"
                  no_log: "{{ nolog }}"
                  with_items:
                    - "{{ scout_control_msgs.fails.local_backup_path_is_not_exists | replace('local_backup_path_folder',local_backup_path) }}"
                  when: not local_backup_path_folder.stat.exists

                - name: print message if local_backup_path is not exists
                  assert:
                    that: local_backup_path_folder.stat.exists
                    fail_msg: "local_backup_path is not exists"

                - name: get a mount point for a folder
                  shell: "df {{ local_backup_path }} | tail -1 | awk '{print $4}'"
                  register: local_backup_path_free
                  when: local_backup_path_folder.stat.exists

                - name: get mount point for local_backup_path
                  shell: "df {{ local_backup_path }} | tail -1 | awk '{print $NF}'"
                  register: local_backup_path_mp

                - name: local_backup_path_free_mb
                  set_fact:
                    local_backup_path_free_mb: "{{ (local_backup_path_free.stdout_lines.0 | int / 1024) | int }}"

            - name: add 1GB for the minimum backup space if local_backup_path_mp.stdout == pgbackup_mp.stdout
              set_fact:
                pgdata_size_need_mb: "{% if local_backup_path_mp.stdout != pgbackup_mp.stdout %}{{ local_size_backup_mb }}\
                                      {% else %}{{ (local_size_backup_mb | int + 1024) }}{% endif %}"

            - name: adding an error to the scout_error_list if local_backup_path does not have enough free space
              set_fact:
                scout_error_list: "{{ scout_error_list + [item] }}"
              no_log: "{{ nolog }}"
              with_items:
                - "{{ scout_control_msgs.fail_space.local_backup_path_no_free_space |\
                       replace('local_backup_path_folder',local_backup_path) |\
                       replace('local_backup_path_free_mb',local_backup_path_free_mb) |\
                       replace('local_size_backup_mb',pgdata_size_need_mb) }}"
              when: pgdata_exists.stat.exists and local_backup_path_free_mb|int < pgdata_size_need_mb|int

          when: is_inner_full_backup and action_type == 'update_major' and ansible_fqdn == current_master

        #Временная проверка свободного места на реплике в точке монтирования pgdata, которое должно быть x2 от размера pgdata на мастере
        - name: temporary pgdata check on a replica
          block:

            - name: calculation of the required free space for pgdata on the replica
              set_fact:
                pgdata_size_mb_x2: "{{ hostvars['master'].pgdata_size_mb | int * 2 }}"

            - name: adding an error to the scout_error_list if pgdata_mp_free_mb does not have enough free space
              set_fact:
                scout_error_list: "{{ scout_error_list + [item] }}"
              no_log: "{{ nolog }}"
              with_items:
                - "{{ scout_control_msgs.fails.no_free_space_in_pgdata_on_replica |\
                       replace('current_replica',current_replica) |\
                       replace('pgdata_mp_free_mb',pgdata_mp_free_mb) |\
                       replace('pgdata_size_mb_x2',pgdata_size_mb_x2) }}"
              when: pgdata_exists.stat.exists and pgdata_mp_free_mb|int < pgdata_size_mb_x2|int

          when: action_type == 'update_major' and current_replica is defined and ansible_fqdn == current_replica

      when: "action_type in ['update_major', 'update_minor']"

  when: inventory_hostname != 'etcd'