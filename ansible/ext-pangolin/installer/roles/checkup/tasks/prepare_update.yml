- name: Set python interpretator
  set_fact:
    ansible_python_interpreter: '{{ python.global_bin_2 }}'

- name: Check that {{ update_status_files.prev_pgse_version }}
  stat:
    path: "{{ update_status_files.dir }}/{{ update_status_files.prev_pgse_version }}"
  register: json_with_prev_pgse_ver
  become: true
    
- name: Remember current PG SE version from service info
  block:

    - name: remember current Pangoli version
      set_fact:
        pg_current_version: "{% if 'platform-v-pangolin-dbms' in ansible_facts.packages %}\
                            {{ ansible_facts.packages['platform-v-pangolin-dbms'][0].version }}\
                            {% else %}\
                            {{ ansible_facts.packages['postgresql-sber-edition'][0].version }}\
                            {% endif %}"
    
    - name: remember current Pangolin  full version without zeros
      set_fact: 
        pg_current_full_version_without_zeros: "{{ pg_current_version.split('.').0 | int }}.\
                                                {{ pg_current_version.split('.').1 | int }}.\
                                                {{ pg_current_version.split('.').2 | int }}"

    - name: create cache update dir
      file:
        path: "{{ update_status_files.dir }}"
        state: directory
        mode: '0700'
        owner: 'postgres'
        group: 'postgres'
        recurse: yes
      
    - name: create {{ update_status_files.prev_pgse_version }} file
      file:
        path: "{{ update_status_files.dir }}/{{ update_status_files.prev_pgse_version }}"
        state: touch
        owner: postgres
        group: postgres
        mode: '600'

    - name: check that {{ update_status_files.prev_pgse_version }} created
      stat:
        path: "{{ update_status_files.dir }}/{{ update_status_files.prev_pgse_version }}"
      register: file_with_prev_pgse_ver_created

    - name: save pg_current_version as json structure
      set_fact:
        json_pg_current_version:
          pg_current_version: '{{ pg_current_version }}'

    - name: write prev pg se version to {{ update_status_files.prev_pgse_version }}
      copy:
        content: "{{ json_pg_current_version | to_json }}"
        dest: '{{ update_status_files.dir }}/{{ update_status_files.prev_pgse_version }}'

    - name: check that {{ update_status_files.prev_pgse_version }} file is exists
      assert:
        that: file_with_prev_pgse_ver_created.stat.exists
        fail_msg: "{{ message_installer.fails.find_version_pangolin }}"

  become: true
  when: "inventory_hostname != 'etcd' and not json_with_prev_pgse_ver.stat.exists and 'update' in action_type"

- name: Read current PG SE version from file
  block:

    - name: fetch {{ update_status_files.prev_pgse_version }} file from master
      fetch:
        src: '{{ update_status_files.dir }}/{{ update_status_files.prev_pgse_version }}'
        dest: '/tmp'

    - name: define dir name for host_name
      set_fact:
        _prepareupdate_dir_name: "{% if inventory_hostname == 'master' %}master\
                                  {% else %}replica{% endif %}"

    - name: read json file with pg_current_version
      include_vars:
        file: "/tmp/{{ _prepareupdate_dir_name }}/{{ update_status_files.dir }}/{{ update_status_files.prev_pgse_version }}"

    - name: print pg_current_version
      debug: 
        msg: "{{ pg_current_version }}"

  become: true
  when: "inventory_hostname != 'etcd' and json_with_prev_pgse_ver.stat.exists and 'update' in action_type"

- name: Sync pg_current_version between hosts
  block:

    - name: sync pg_current_version between hosts
      set_fact: 
        pg_current_version: "{{ pg_current_version }}"

    - name: sync current Pangolin full version without zeros between hosts
      set_fact: 
        pg_current_full_version_without_zeros: "{{ pg_current_version.split('.').0 | int }}.\
                                                {{ pg_current_version.split('.').1 | int }}.\
                                                {{ pg_current_version.split('.').2 | int }}"

    - name: print pg_current_version
      debug: 
        msg: "{{ pg_current_version }}"

    - name: print current Pangolin full version without zeros
      debug: 
        msg: "{{ pg_current_full_version_without_zeros }}"

  run_once: true
  when: "action_type in ['update_major', 'update_minor']"

- name: Save backup dir path
  set_fact:
    backup_root_dir: "{{ backup_main_dir }}/{{ pg_current_version }}/{{ ansible_date_time.date }}-T{{ ansible_date_time.hour }}{{ ansible_date_time.minute }}"
    cacheable: yes
  run_once: true

- name: Get PGDATA_OLD, PGHOME_OLD
  block:

    - name: check patroni configuration files
      block:

        - name: check that patroni yml config is exists
          stat:
            path: "{{ patroni_files.conf_dir }}/postgres.yml"
          register: patroni_yml_file

        - name: check that patroni systemd config is exists
          stat:
            path: "{{ patroni_files.service_file }}"
          register: patroni_systemd_file
          become_user: root

        - name: define patroni_config_files variable
          set_fact:
            patroni_config_files: "{% if patroni_yml_file.stat.exists and patroni_systemd_file.stat.exists %}true{% else %}false{% endif %}"

    - name: get PGDATA_OLD and define some variables if patroni installed
      block:

        - name: get PGDATA_OLD
          reciter:
            ANSIBLE_MODULE_ARGS:
              src: "{{ patroni_files.conf_dir }}/postgres.yml"
              action: get
              parameter: postgresql
              inner_parameter: data_dir
          register: pgdata_old

        - name: get PGHOME_OLD
          reciter:
            ANSIBLE_MODULE_ARGS:
              src: "{{ patroni_files.conf_dir }}/postgres.yml"
              action: get
              parameter: postgresql
              inner_parameter: bin_dir
          register: pghome_old

        - name: define some variables
          set_fact:
            PGDATA_OLD: "{{ pgdata_old.message }}"
            PGHOME_OLD: "{{ pghome_old.message | replace('/bin', '') }}"

      environment:
        - PYTHONPATH: "{{ python.postgresql_venv_packages }}"
      when: "installation_type =='cluster' or patroni_config_files"

    - name: get PGDATA_OLD and define some variables if patroni not installed
      block:

        - name: get PGDATA_OLD
          reciter:
            ANSIBLE_MODULE_ARGS:
              src: "{{ postgresql_files.service_file }}"
              action: get
              parameter: ExecStart
          register: pgdata_old

        - name: get PGHOME_OLD
          reciter:
            ANSIBLE_MODULE_ARGS:
              src: "{{ postgresql_files.service_file }}"
              action: get
              parameter: WorkingDirectory
          register: pghome_old

        - name: define some variables
          set_fact:
            PGDATA_OLD: "{{ pgdata_old.message.split('-D ')[-1] }}"
            PGHOME_OLD: "{{ pghome_old.message }}"
      
      environment:
        - PYTHONPATH: "{{ python.postgresql_venv_packages }}"
      become_user: root
      when: "installation_type =='standalone' and not patroni_config_files "

    - name: check if pgdata_old is link
      stat:
        path: "{{ (PGDATA_OLD | regex_replace('/$', '')).split('/')[0:-1] | join ('/') }}"
      register: pgdata_link

    - name: save PGDATA_OLD main
      set_fact:
        PGDATA_OLD: "{% if pgdata_link.stat.islnk %}{{ pgdata_link.stat.lnk_source }}/data{% else %}{{ PGDATA_OLD }}{% endif %}"

    - name: grep PYTHON_VENV_OLD
      block:

        - name: get PYTHON_VENV_OLD
          reciter:
            ANSIBLE_MODULE_ARGS:
              src: "{{ patroni_files.service_file }}"
              action: get
              parameter: ExecStart
          register: python_venv_old
          environment:
            - PYTHONPATH: "{{ python.postgresql_venv_packages }}"
          become_user: root

        - name: save PYTHON_VENV_OLD
          set_fact:
            PYTHON_VENV_OLD: "{% if ( [ pg_current_version, '4.4.0' ] | compare_pg_se_versions )|int == 0 %}{{ python_venv_old.message.split().0 | replace('bin/python3','')}}\
                              {% else %}{{ python_venv_old.message.split().0 | replace('bin/patroni_bin/patroni.bin','')}}{% endif %}"

      when: patroni_config_files

    - name: define variable if patroni configuration files aren't exist
      set_fact:
        PYTHON_VENV_OLD: null
      when: not patroni_config_files

  become: true
  become_user: postgres
  when: inventory_hostname != 'etcd'

# TODO: pgdata_new_string и pgdata_old_string определять через set_fact
- name: Remember short names path for symlink
  block:

    - name: remember short {{ PGDATA_OLD }} path for symlink
      shell: "echo {{ PGDATA_OLD }} | cut -d '/' -f 1,2,3"
      register: pgdata_old_string

    - name: remember short {{ PGDATA }} path for symlink
      shell: "echo {{ PGDATA }} | cut -d '/' -f 1,2,3"
      register: pgdata_new_string

  when: inventory_hostname != 'etcd'

- name: Check exists components
  import_tasks: check_exist_components_and_define_configuration_type.yml

- name: Get and save PGPORT_OLD, PGBOUNCERPORT_OLD, CLNAME_OLD and PGHOME_OLD_NAME
  block:

    - name: get PGPORT_OLD
      reciter:
        ANSIBLE_MODULE_ARGS:
          src: "{{ PGDATA_OLD }}/postgresql.conf"
          action: get
          parameter: port
      register: pgport_old
      environment:
        - PYTHONPATH: "{{ python.postgresql_venv_packages }}"

    - name: save old PGPORT
      set_fact:
        PGPORT_OLD: "{{ pgport_old.message }}"

    - name: get CLNAME_OLD
      shell: echo $CLNAME
      register: clname_old
      become_flags: "-i"

    - name: print message if clustername not found
      assert:
        that: clname_old.stdout|length > 0
        fail_msg: "{{ update_control_msgs.fails.cluster_name_found }}"

    - name: save current clustername
      set_fact:
        clustername: "{{ clname_old.stdout }}"
      run_once: true

    - name: save PGHOME directory name
      set_fact:
        PGHOME_OLD_NAME: "{{ PGHOME_OLD.replace('/', ' ').split() | last }}"

    - name: save PGBOUNCERPORT_OLD port
      block:

        - name: setup python version for reciter
          set_fact:
            ansible_python_interpreter: '{{ python.postgresql_venv }}/bin/python3'

        - name: check current port of pgbouncer
          reciter:
            ANSIBLE_MODULE_ARGS:
              src: "{{ pgbouncer_files.conf_dir }}/pgbouncer.ini"
              action: get
              parameter: listen_port
          register: pgbouncerport_old
          environment:
            - PYTHONPATH: "{{ python.postgresql_venv_packages }}"

        - name: save old PGBOUNCERPORT_OLD
          set_fact:
            PGBOUNCERPORT_OLD: "{{ pgbouncerport_old.message }}"

        - name: undo previous stage with set_fact
          set_fact:
            ansible_python_interpreter: '{{ python.global_bin_2 }}'

      when: pgbouncer

    - name: save HAPROXYPORT_OLD port
      block:

        - name: grep HAPROXYPORT_OLD
          shell: "cat {{ haproxy_files.conf_dir }}/haproxy.cfg | grep 'frontend fe_postgresql' -A 3 | grep bind | awk -F ' ' '{ print $2 }' | awk -F ':' '{print $2}'"
          ignore_errors: true
          register: haproxyport_old

        - name: save HAPROXYPORT_OLD
          set_fact:
            HAPROXYPORT_OLD: "{{ haproxyport_old.stdout }}"
          when: haproxyport_old|length > 0
        
      when: haproxy
    
  become: true
  become_user: postgres
  when: inventory_hostname != 'etcd'

- name: Check PGPORT is opened and DB work
  shell: '{{ PGHOME_OLD }}/bin/pg_isready -h {{ ansible_fqdn }} -p {{ PGPORT_OLD }}'
  register: db_status_work
  ignore_errors: true
  become: true
  become_user: postgres
  when: inventory_hostname != 'etcd'

- name: Generate certs for version below 4.2.1 and version without certs
  import_tasks: 'prepare_update_certs.yml'
  when: "inventory_hostname != 'etcd' and not db_status_work.failed"

- name: Get and save current certificates
  block:

    - name: check currents certs
      shell: "{{ item_cmd }}"
      loop:
        - grep -E 'PGSSLCERT|sslcert' {{ PGUSERHOME }}/.bash_profile | grep -v '^#'
        - grep -E 'PGSSLKEY|sslkey' {{ PGUSERHOME }}/.bash_profile | grep -v '^#'
        - grep -E 'PGSSLROOTCERT|sslrootcert' {{ PGUSERHOME }}/.bash_profile | grep -v '^#'
      loop_control:
        loop_var: item_cmd
      register: ssl_client_certs
      ignore_errors: true

    - name: define current certs
      set_fact:
        client_cert: "{{ ssl_client_certs.results[ 0 ].stdout | get_cert_path('PGSSLCERT|sslcert') }}"
        client_key: "{{ ssl_client_certs.results[ 1 ].stdout | get_cert_path('PGSSLKEY|sslkey') }}"
        client_ca: "{{ ssl_client_certs.results[ 2 ].stdout | get_cert_path('PGSSLROOTCERT|sslrootcert') }}"

    - name: list client certificates
      set_fact:
        list_client_certs: [ "{% if client_cert|length > 0 %}{{ client_cert }}{% else %}PGSSLCERT{% endif %}",
                             "{% if client_key|length > 0 %}{{ client_key }}{% else %}PGSSLKEY{% endif %}",
                             "{% if client_ca|length > 0 %}{{ client_ca }}{% else %}PGSSLROOTCERT{% endif %}" ]

    - name: check that cerificates exists
      stat:
        path: "{{ item }}"
      loop: "{{ list_client_certs }}"
      register: cert_stat

    - name: print message if certificates not exits
      assert:
        that: cert_stat.results[ index ].stat.exists
        fail_msg: "{{ update_control_msgs.fails.found_cert.format(item) }}"
      loop: "{{ list_client_certs }}"
      loop_control:
        index_var: index

    - name: redefine client certificates
      import_tasks: redefine_variables.yml
      vars:
        _redefinevars_client_cert: "{{ client_cert }}"
        _redefinevars_client_key: "{{ client_key }}"
        _redefinevars_client_ca: "{{ client_ca }}"

  become: true
  become_user: postgres
  when: inventory_hostname != 'etcd'

- name: Check variables and check configuration type
  block:

    - name: check cluster configuration and component installed
      block:

        - name: set python interpretator
          set_fact:
            ansible_python_interpreter: '{{ python.postgresql_venv }}/bin/python3'

        - name: save PGBACKUP_OLD query
          postgresql_query:
            query: SELECT setting FROM backup.settings
            port: "{{ PGPORT_OLD }}"
          register: pgbackup_old_query
          become: true
          become_user: postgres
          environment: "{{ db_connection_args }}"

        - name: save old PGBACKUP_OLD
          set_fact:
            PGBACKUP_OLD: "{{ pgbackup_old_query.query_result[0].setting }}"

        - name: get installer.cluster_type
          postgresql_query:
            port: "{{ PGPORT_OLD }}"
            query: SHOW installer.cluster_type
          register: current_cluster_type
          become: true
          become_user: postgres
          environment: "{{ db_connection_args }}"

        - name: check cluster_type from DB and actual state
          assert:
            that: item.value == tag
            fail_msg: "{{ update_control_msgs.fails.type_configuration }}"
          with_dict: "{{ current_cluster_type.query_result }}"

    - name: check PGHOME_OLD_NAME exist
      assert:
        that: "PGHOME_OLD_NAME|length > 0"
        fail_msg: "PGHOME_OLD_NAME didn't load"
        success_msg: "PGHOME_OLD_NAME = {{ PGHOME_OLD_NAME }}"

    - name: check PGHOME_OLD exist
      assert:
        that: "PGHOME_OLD|length > 0"
        fail_msg: "PGHOME_OLD didn't load"
        success_msg: "PGHOME_OLD = {{ PGHOME_OLD }}"

    - name: check PGDATA_OLD exist
      assert:
        that: "PGDATA_OLD|length > 0"
        fail_msg: "PGDATA_OLD didn't load"
        success_msg: "PGDATA_OLD = {{ PGDATA_OLD }}"
    
    - name: check PGPORT_OLD exist
      assert:
        that: "PGPORT_OLD|length > 0"
        fail_msg: "PGPORT_OLD didn't load"
        success_msg: "PGPORT_OLD = {{ PGPORT_OLD }}"

    - name: check PGBOUNCERPORT_OLD exist
      assert:
        that: "PGBOUNCERPORT_OLD|length > 0"
        fail_msg: "PGBOUNCERPORT_OLD didn't load"
        success_msg: "PGBOUNCERPORT_OLD = {{ PGBOUNCERPORT_OLD }}"
      when: pgbouncer

    - name: check HAPROXYPORT_OLD exist
      assert:
        that: "HAPROXYPORT_OLD|length > 0"
        fail_msg: "HAPROXYPORT_OLD didn't load"
        success_msg: "HAPROXYPORT_OLD = {{ HAPROXYPORT_OLD }}"
      when: haproxy

    # - name: check PGBACKUP_OLD exist
    #   assert:
    #     that: "PGBACKUP_OLD|length > 0"
    #     fail_msg: "PGBACKUP_OLD didn't load"
    #     success_msg: "PGBACKUP_OLD = {{ PGBACKUP_OLD }}"

    - name: check PYTHON_VENV_OLD exist
      assert:
        that: "PYTHON_VENV_OLD|length > 0"
        fail_msg: "PYTHON_VENV_OLD didn't load"
        success_msg: "PYTHON_VENV_OLD = {{ PYTHON_VENV_OLD }}"
      when: is_patroni_exists

    - name: check tag, some configuration type have to actual value
      assert:
        that: "tag|length > 0"
        fail_msg: "tag didn't load"
        success_msg: "tag = {{ tag }}"

  when: inventory_hostname != 'etcd'

- name: Set max_worker_processes for update
  block:

    - name: define current max_worker_processes
      postgresql_query:
        port: "{{ ports.pg }}"
        query: show max_worker_processes
      register: _upd_cur_max_worker_processes
      become: true
      become_user: postgres
      environment:
        - PGHOST: "{{ ansible_fqdn }}"
        - PGSSLCERT: "{{ pg_certs_pwd.postgres_cert }}"
        - PGSSLKEY: "{{ pg_certs_pwd.postgres_key }}"
        - PGSSLROOTCERT: "{{ pg_certs_pwd.root_ca }}"

    - name: set max_worker_processes for update
      set_fact:
        _upd_max_worker_processes: "{{ _upd_cur_max_worker_processes.query_result[0].max_worker_processes }}"

  run_once: true
  when: inventory_hostname != 'etcd'

- name: define roles of nodes
  include_role:
    name: patroni
    tasks_from: update_define_roles_of_nodes.yml
  when: "action_type in ('scouting_users','unlock_reset_user','scouting_create_user','create_user','get_installed_contrib_ext','install_contrib_ext','scouting_pgbouncer','scout_edit_pg_hba','update_minor')"

- name: Set python interpretator
  set_fact:
    ansible_python_interpreter: '{{ python.global_bin_2 }}'