- name: Checkup
  block:

    - name: copy info about user agreement status
      block:

        - name: get UTC current time
          command: "date '+%Y-%m-%d_%H:%M:%S'"
          register: date_utc
          environment:
            TZ: UTC

        - name: create {{ PGUSERHOME }}/.user_agreement_statuses if it doesn't exists
          file:
            path: "{{ PGUSERHOME }}/.user_agreement_statuses"
            state: directory
            mode: '0700'
            owner: 'postgres'
            group: 'postgres'
            recurse: yes

        - name: copy info about user agreement status
          copy:
            src: "{{ playbook_dir }}/files/user_agreement.json"
            dest: "{{ PGUSERHOME }}/.user_agreement_statuses/user_agreement_{{ date_utc.stdout }}.json"
            owner: postgres
            group: postgres
            mode: u=r,g=r,o=r

      become: true
      when: "'update' in action_type and is_user_agreement_statuses_file"

    - name: include update variables
      include_vars:
        file: "group_vars/update.yml"
      no_log: "{{ nolog }}"
      when: "action_type in ['update_major', 'update_minor']"

    - name: include install variables
      include_vars:
        file: "group_vars/message.yml"
      no_log: "{{ nolog }}"

    - name: check passed action type
      assert:
        that: action_type in supported_action_types.installer
        fail_msg: "{{ message_installer.fails.missing_configuration }}"
      run_once: true

    - name: import error info file for recovery test mode
      include_vars: file="{{ playbook_dir }}/scripts/update_error_types.yml"
      no_log: "{{ nolog }}"
      when: is_recovery_test_mode

    - name: check and use custom_config
      import_tasks: check_and_use_custom_config.yml

    - name: check KillUserProcesses in /etc/systemd/logind.conf
      lineinfile:
        dest: /etc/systemd/logind.conf
        line: KillUserProcesses=yes
      register: _kill_user_processes
      check_mode: true
      become: true

    - name: assert if KillUserProcesses not change
      assert:
        that: _kill_user_processes.changed
        fail_msg: "{{ message_installer.fails.kill_user_process_on | replace('host_name', inventory_hostname)}}"

    - name: define cpu count for used
      set_fact:
        proc_cpu_for_ansible_used: "{% if ansible_processor_vcpus >= 4 %}{{ ansible_processor_vcpus - 2 }}{% else %}1{% endif %}"

    - name: import tls checkup
      include_role:
        name: tls
        tasks_from: checkup.yml
      when: "custom_config|length > 0 and action_type == 'install' and ldap_tls is defined and ldap_tls"

    - name: check ansible environment
      import_tasks: ansible_env.yml
      run_once: true

    - name: check input variables
      import_tasks: verify_variables.yml
      run_once: true
      when: action_type == 'install'

    - name: check fqdn of hosts
      assert:
        that: not 'localhost' in ansible_fqdn
        fail_msg: "{{ message_installer.fails.incorrect_fqdn }}"

    - name: check system version
      assert:
        that: ansible_distribution_version|float >= {{ required_os_version.min }} and ansible_distribution_version|float <= {{ required_os_version.max }}
        fail_msg: "{{ message_installer.fails.system_version }}"
        success_msg: "{{ message_installer.info.system_version }}"
      when: skip_distr_and_os_version is not defined or (skip_distr_and_os_version is defined and not skip_distr_and_os_version)

    - name: check python version
      assert:
        that: ansible_python_version|version == 2.7
        fail_msg: "{{ message_installer.fails.python_version }}"
        success_msg: "{{ message_installer.info.python_version }}"
      when: ansible_os_family == "RedHat"

    - name: set name of package
      import_tasks: find_package.yml

    - name: check remote linux environment
      import_tasks: linux_env.yml

    - name: check connect to KMS server
      block:

        - name: get status of kms serves
          wait_for:
            host: "{{ KMS_HOST }}"
            port: "{{ KMS_PORT }}"
            timeout: 5
          register: kms_status
          ignore_errors: yes

        - name: check that kms server started
          assert:
            that: not kms_status.failed
            fail_msg: "KMS server is not running. TDE and admin protection cannot be configured"

        - name: get KMS version with api
          uri:
            url: "https://{{ KMS_HOST }}:{{ KMS_PORT }}/v1/sys/health"
            validate_certs: no
            return_content: yes
          register: kms_version
          when: not kms_status.failed

        - name: check kms version
          assert:
            that: kms_version.json.version|version >= KMS_VERSION|version
            fail_msg: "{{ message_installer.fails.kms_version.format(kms_version.json.version, KMS_VERSION) }}"
            success_msg: "{{ message_installer.info.kms_version }}"
          when: not kms_status.failed

      delegate_to: localhost
      run_once: true
      when: "tde is defined and admin_protection is defined and (tde or admin_protection)"

    #TODO Checking free virtual memory
    - name: check PGHOME not exist, if actual type is install
      block:

        - name: check PGHOME not exist
          find:
            path: "{{ item.0 }}"
            file_type: directory
            use_regex: yes
            patterns: "{{ item.1 }}"
          with_nested:
            - [ "/usr", "/usr/local" ]
            - [ "pgsql*", "pangolin*"]
          register: pghome_exists

        - name: check that PGHOME doesn't exists
          assert:
            that: not item.matched
            fail_msg: "{{ message_installer.fails.checking_exists_dir | replace('exists_path', '{}/{}'.format(item.item.0, item.item.1)) }}"
            success_msg: "{{ message_installer.info.checking_exists_dir | replace('exists_path', '{}/{}'.format(item.item.0, item.item.1)) }}"
          with_items: "{{ pghome_exists.results }}"

      when: action_type == 'install'

    - name: include task file for install python venv for ansible use
      include_role:
        name: checkup
        tasks_from: python_env

    - debug: msg="{{ update_error_types_breakpoint_msg }}"
      when: is_recovery_test_mode and checkup_error_um001m and inventory_hostname == 'master'
    - debug: msg="{{ update_error_types_breakpoint_msg }}"
      when: is_recovery_test_mode and checkup_error_um001r and inventory_hostname == 'replica'
    - debug: msg="{{ update_error_types_breakpoint_msg }}"
      when: is_recovery_test_mode and checkup_error_um001e and inventory_hostname == 'etcd'

    - name: check it when defined action only installation
      import_tasks: check_action_install.yml
      when: action_type == 'install'

    - name: generate random patroni_etcd_pass, etcd_root_pass passwords
      block:

        - name: generate passwords for patroni_etcd_pass, etcd_root_pass
          password_generator:
            ANSIBLE_MODULE_ARGS:
              min_length: '{{ password_policy_params.min_length }}'
              alpha_numeric: '{{ password_policy_params.alpha_numeric }}'
              min_alpha_chars: '{{ password_policy_params.min_alpha_chars }}'
              min_special_chars: '{{ password_policy_params.min_special_chars }}'
              min_uppercase: '{{ password_policy_params.min_uppercase }}'
              min_lowercase: '{{ password_policy_params.min_lowercase }}'
              max_rpt_chars: '{{ password_policy_params.max_rpt_chars }}'
          register: new_pass
          environment:
            - PYTHONPATH: "{{ python.postgresql_venv_packages }}"
          become: true
          run_once: true
          loop: [patroni_etcd_pass, etcd_root_pass]

        - name: save passwords for patroni_etcd_pass and etcd_root_pass
          set_fact:
            patroni_etcd_pass: '{{ new_pass.results[0].message }}'
            etcd_root_pass: '{{ new_pass.results[1].message }}'

      no_log: "{{ nolog }}"

    - name: check it when defined action only updating
      import_tasks: check_action_update.yml
      when: "action_type in ['update_major', 'update_minor']"

    - name: set python interpretator
      set_fact:
        ansible_python_interpreter: '{{ python.global_bin_2 }}'

    - name: include_role
      include_role:
        name: common
        tasks_from: sudoers

    - debug: msg="{{ update_error_types_breakpoint_msg }}"
      when: is_recovery_test_mode and checkup_error_um002m and inventory_hostname == 'master'
    - debug: msg="{{ update_error_types_breakpoint_msg }}"
      when: is_recovery_test_mode and checkup_error_um002r and inventory_hostname == 'replica'
    - debug: msg="{{ update_error_types_breakpoint_msg }}"
      when: is_recovery_test_mode and checkup_error_um002e and inventory_hostname == 'etcd'

  rescue:

    - name: replica updated with error
      set_fact:
        update_errors: "{{ update_errors|combine(data, recursive=True) }}"
        cacheable: yes
      vars:
        data:
          aggregate: true
          hosts:
            replica: true
          components:
            checkup: true
      run_once: true
      when: inventory_hostname == 'replica'

    - name: master updated with error
      set_fact:
        update_errors: "{{ update_errors|combine(data, recursive=True) }}"
        cacheable: yes
      vars:
        data:
          aggregate: true
          hosts:
            master: true
          components:
            checkup: true
      run_once: true
      when: inventory_hostname == 'master'

    - name: etcd updated with error
      set_fact:
        update_errors: "{{ update_errors|combine(data, recursive=True) }}"
        cacheable: yes
      vars:
        data:
          aggregate: true
          hosts:
            etcd: true
          components:
            checkup: true
      run_once: true
      when: inventory_hostname == 'etcd'

  always:

    - name: write to process status work
      include_role:
        name: common
        tasks_from: add_process_status_logs
      vars:
        process_work_status: "{% if 'update' in action_type %}\
                                  {{ process_work_statuses.all_updates.start }}\
                              {% else %}\
                                  {{ process_work_statuses.installation.start }}\
                              {% endif %}"
      when: "not update_errors.aggregate \
             and inventory_hostname != 'etcd'"

    - name: to stop install process if error
      fail: msg='Install process must be stopped by error'
      when: "action_type == 'install' and \
            hostvars['master' or 'replica' or 'etcd'].update_errors.aggregate"
