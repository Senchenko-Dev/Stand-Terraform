- name: Roles
  block:

    - name: set common role facts
      set_fact:
        role_conn_limit: 5
        noinherit_role_attr: 'NOINHERIT'
        inherit_role_attr: 'INHERIT'

    - name: create roles and set passwords and grant privs
      block:

        - name: create roles or configure, if exist
          postgresql_user:
            port: "{{ ports.pg }}"
            name: "{{ item.role }}"
            conn_limit: "{{ role_conn_limit }}"
            expires: 'infinity'
            role_attr_flags: "{{ item.privs }}"
          loop:
            - { role: "{{ db_admin }}",     privs: "{% if action_type == 'install' or cfg_main_roles %}NOLOGIN,CREATEDB,CREATEROLE,SUPERUSER{% endif %}" }
            - { role: "{{ as_group }}",     privs: "{% if action_type == 'install' or cfg_main_roles %}NOLOGIN,NOINHERIT{% endif %}" }
            - { role: "{{ TUZ_group }}",    privs: "{% if action_type == 'install' or cfg_main_roles %}NOLOGIN,INHERIT{% endif %}" }
            - { role: "as_admin_read",      privs: 'NOLOGIN,NOINHERIT' }
            - { role: "all-sa-pam-group",   privs: 'NOLOGIN,NOINHERIT' }
            - { role: "all-sa-pam19002",    privs: 'LOGIN,CREATEDB,CREATEROLE,SUPERUSER,NOINHERIT' }
            - { role: "all-sa-pam19002_ro", privs: 'LOGIN,INHERIT' }

        - name: checking the current as_admin list
          postgresql_query:
            port: "{{ ports.pg }}"
            query: SELECT rolname FROM pg_roles where 'role=as_admin' = ANY(rolconfig)
          register: admins
          when: "action_type in ['update_major', 'update_minor']"

        - name: configuring current as_admin roles with VALID UNTIL
          postgresql_query:
            port: "{{ ports.pg }}"
            query: ALTER ROLE "{{ item.rolname }}" VALID UNTIL '{{ ROLES_EXPIRES_DATE }}'
          with_items: "{{ admins.query_result }}"
          when: "action_type in ['update_major', 'update_minor']"

    - name: create or alter ldap {{ as_admins }} role DEV
      postgresql_user:
        port: "{{ ports.pg }}"
        name: "{{ item }}"
        password: "{{ db_group_roles.as_admin.pass.open }}"
        role_attr_flags: "{{ noinherit_role_attr }}"
        groups: "{{ as_group }},{{ db_admin }}"
        expires: "{{ ROLES_EXPIRES_DATE }}"
        conn_limit: "{{ role_conn_limit }}"
      loop: "{{ as_admins }}"
      when: "stand == 'dev' and 'update' not in action_type"

    - name: create or alter {{ as_admins }} role notDEV
      postgresql_user:
        port: "{{ ports.pg }}"
        name: "{{ item }}"
        password: "{{ db_group_roles.as_admin.pass.open }}"
        role_attr_flags: "{{ noinherit_role_attr }}"
        groups: "{{ as_group }}"
        expires: "{{ ROLES_EXPIRES_DATE }}"
        conn_limit: "{{ role_conn_limit }}"
      loop: "{{ as_admins }}"
      loop_control:
        index_var: index
      when: "stand != 'dev' and 'update' not in action_type"

    - name: configure {{ as_admins }} roles with default set_role
      postgresql_query:
        port: "{{ ports.pg }}"
        query: ALTER ROLE "{{ item }}" set role "{{ as_group }}";
      loop: "{{ as_admins }}"
      when: "'update' not in action_type"

    - name: create {{ as_TUZ }} users
      block:

        - name: create {{ as_TUZ }} users
          postgresql_query:
            port: "{{ ports.pg }}"
            query: "CREATE USER \"{{ item }}\" {% if password_policy_params.is_temp_tuz_password %}TEMPORARY{% endif %} \
                    PASSWORD '{{ db_group_roles.transport.pass.open }}' {{ inherit_role_attr }};"
          loop: "{{ as_TUZ }}"

        - name: grant {{ as_TUZ }} users to {{ TUZ_group }}
          postgresql_query:
            port: "{{ ports.pg }}"
            query: GRANT "{{ TUZ_group }}" TO "{{ item }}"
          loop: "{{ as_TUZ }}"

      when: "'update' not in action_type"

    - name: create user for pg_probackup and added grant
      block:

        - name: create backup_user role with random password
          block:

            - name: create backup_user role with test password
              include_role:
                name: postgresql 
                tasks_from: generate_and_update_db_user_pass.yml
              vars:
                _genupdatepass_dbuser: backup_user
                _genupdatepass_generated_pass: "{{ pg_backup_user_passwd }}"
              when: inner_install

            - name: create backup_user role with random password
              include_role:
                name: postgresql 
                tasks_from: generate_and_update_db_user_pass.yml
              vars:
                _genupdatepass_dbuser: backup_user
              when: not inner_install

            - name: save pg_backup_user_passwd
              set_fact:
                pg_backup_user_passwd: "{{ _genupdatepass_generated_pass }}"
              no_log: "{{ nolog }}"
              when: not inner_install

          run_once: true

        - name: add grant for user pg_probackup
          postgresql_query:
            port: "{{ ports.pg }}"
            query: "{{ item }}"
          with_items:
            - ALTER USER "backup_user" WITH REPLICATION NOINHERIT;
            - GRANT USAGE ON SCHEMA pg_catalog TO "backup_user";
            - GRANT EXECUTE ON FUNCTION pg_catalog.current_setting(text) TO "backup_user";
            - GRANT EXECUTE ON FUNCTION pg_catalog.pg_is_in_recovery() TO "backup_user";
            - GRANT EXECUTE ON FUNCTION pg_catalog.pg_start_backup(text, boolean, boolean) TO "backup_user";
            - GRANT EXECUTE ON FUNCTION pg_catalog.pg_stop_backup(boolean, boolean) TO "backup_user";
            - GRANT EXECUTE ON FUNCTION pg_catalog.pg_create_restore_point(text) TO "backup_user";
            - GRANT EXECUTE ON FUNCTION pg_catalog.pg_switch_wal() TO "backup_user";
            - GRANT EXECUTE ON FUNCTION pg_catalog.pg_last_wal_replay_lsn() TO "backup_user";
            - GRANT EXECUTE ON FUNCTION pg_catalog.txid_current() TO "backup_user";
            - GRANT EXECUTE ON FUNCTION pg_catalog.txid_current_snapshot() TO "backup_user";
            - GRANT EXECUTE ON FUNCTION pg_catalog.txid_snapshot_xmax(txid_snapshot) TO "backup_user";
            - GRANT EXECUTE ON FUNCTION pg_catalog.pg_control_checkpoint() TO "backup_user";

    - name: create or update pass for zabbix_oasubd, monitoring_php and auditor users
      include_tasks: update_user_pass.yml
      vars:
        username: "{{ item.uname }}"
        password: "{{ item.pass }}"
      with_items:
        - { uname: "zabbix_oasubd",  pass: "{{ zabbix_oasubd_scram_pass }}" }
        - { uname: "monitoring_php", pass: "{{ monitoring_php_scram_pass }}" }
        - { uname: "auditor",        pass: "{{ auditor_scram_pass }}" }

    - name: include file with tasks for configure special password policies for TUZ users
      import_tasks: setup_special_pp_policies.yml

    - name: drop masteromni, pstgcmdb and sberpg roles
      import_tasks: update_apply_sql_scripts.yml
      vars:
        drop_roles: true
      when: "'update' in action_type and ( [ pg_current_version, '4.4.0' ] | compare_pg_se_versions )|int == 0"

  environment: "{{ db_connection_args }}"
  become: true
  become_user: postgres
  when: ansible_fqdn == current_master