- name: Configure Pangolin
  block:

    - name: set python interpretator
      set_fact:
        ansible_python_interpreter: '{{ python.postgresql_venv }}/bin/python3'

    - name: define current master role of the cluster
      include_role:
        name: patroni
        tasks_from: update_define_roles_of_nodes.yml

    - name: change role of current host in cluster
      include_role:
        name: patroni
        tasks_from: update_run_switchover
      vars:
        current_database_port: "{{ ports.pg }}"
      run_once: true
      when: installation_type == 'cluster' and hostvars['master'].ansible_fqdn != current_master

    - name: define current PGDATA and PGHOME
      set_fact:
        the_configure_pgdata: "{{ PGDATA_OLD }}"
        the_configure_pghome: "{{ PGHOME_OLD }}"
      when: "'update' in action_type and not postgres"

    - name: define current PGDATA and PGHOME
      set_fact:
        the_configure_pgdata: "{{ PGDATA }}"
        the_configure_pghome: "{{ PGHOME }}"
      when: action_type == 'install' or postgres

    - name: block traffic for {{ PGPORT_OLD }}
      include_role:
        name: common
        tasks_from: block_traffic
      vars:
        block_traffic: true
        the_current_haproxy_port: "{{ ports.haproxy }}"
        the_current_pgbouncer_port: "{{ ports.pgbouncer }}"
        the_current_pg_port: "{{ ports.pg }}"
      when: "is_downtime_configure_module \
             and action_type == 'update_minor'"

    - name: enable allow_hashed_password and cert auth and login {{ as_group }} in pg_hba
      block:

        - name: turn on allow_hashed_password and cert auth in postgres.yml
          reciter:
            ANSIBLE_MODULE_ARGS:
              src: "{{ patroni_files.conf_dir }}/postgres.yml"
              action: set
              parameter: "postgresql.parameters"
              inner_parameter: "{{ item.inner_param }}"
              new_val: "{{ item.val }}"
          environment:
            - PYTHONPATH: "{{ python.postgresql_venv_packages }}"
          with_items:
            - { inner_param: 'password_policy.allow_hashed_password' , val: 'on'  }
            - { inner_param: 'enabled_sec_admin_extra_auth_methods' ,  val: 'cert'  }
            - { inner_param: 'enabled_extra_auth_methods' ,            val: 'cert'  }
          when: patroni

        - name: turn on allow_hashed_password and cert auth in postgresql.conf
          lineinfile:
            path: '{{ the_configure_pgdata }}/postgresql.conf'
            regexp: "{{ item.regexp }}"
            line: "{{ item.line }}"
          with_items:
            - { regexp: 'password_policy.allow_hashed_password' , line: "password_policy.allow_hashed_password = 'on'" }
            - { regexp: 'enabled_sec_admin_extra_auth_methods' ,  line: "enabled_sec_admin_extra_auth_methods = 'cert'" }
            - { regexp: 'enabled_extra_auth_methods' ,            line: "enabled_extra_auth_methods = 'cert'" }
          when: not patroni

        - name: send reload command to postgresql
          shell: "{{ the_configure_pghome }}/bin/pg_ctl reload -D {{ the_configure_pgdata }}"
          when: not patroni

        - name: send reload command to patroni
          include_role:
            name: patroni
            tasks_from: update_with_patronictl
          vars:
            endpoint_name: reload
            PGHOME: "{{ the_configure_pghome }}"
          when: patroni

      run_once: true
      become_user: postgres
      become: true

    - name: tuning
      block:

        - name: update extensions
          block:

            - name: request to get all databases
              postgresql_query:
                port: "{{ ports.pg }}"
                query: SELECT datname FROM pg_database WHERE datallowconn
              register: query_all_database

            - name: remove pg_repack before update
              block:

                - name: request pg_repack extension that installed in Pangolin
                  postgresql_query:
                    port: "{{ ports.pg }}"
                    db: "{{ item.datname }}"
                    query: "SELECT format('{{ item.datname }}.%1$s.%2$s',nspname,extname) extname FROM pg_catalog.pg_extension ex \
                              JOIN pg_namespace ns ON ex.extnamespace =ns.oid \
                            WHERE ex.extname='pg_repack';"
                  register: query_pg_repack_ext_pgse
                  with_items: "{{ query_all_database.query_result }}"

                - name: installed ext pangolin
                  set_fact:
                    installed_pg_repack_pangolin: "{{ query_pg_repack_ext_pgse.results|
                                                  map('dict2items')|list|flatten|
                                                  json_query('[?key==`query_result`].value')|flatten|
                                                  map('dict2items')|list|
                                                  json_query('[*][?key==`extname`].value')|flatten }}"

                - name: update the latest available version of extensions
                  postgresql_ext:
                    port: "{{ ports.pg }}"
                    db: "{{item.split('.').0}}"
                    name: "{{item.split('.').2}}"
                    cascade: yes
                    state: absent
                  loop: "{{ installed_pg_repack_pangolin }}"

            - name: request a list of extensions that are part of Pangolin
              postgresql_query:
                port: "{{ ports.pg }}"
                db: "{{ item.datname }}"
                query: "SELECT format('{{ item.datname }}.%1$s',extname) extname FROM pg_catalog.pg_extension ex \
                          JOIN pg_namespace ns ON ex.extnamespace =ns.oid \
                        WHERE ex.extname in ({{ legal_extensions.third_party }}, {{ legal_extensions.contrib }});"
              register: query_installed_ext_pgse
              with_items: "{{ query_all_database.query_result }}"

            - name: installed ext pangolin
              set_fact:
                installed_ext_pangolin: "{{ query_installed_ext_pgse.results|
                                        map('dict2items')|list|flatten|
                                        json_query('[?key==`query_result`].value')|flatten|
                                        map('dict2items')|list|
                                        json_query('[*][?key==`extname`].value')|flatten }}"

            - name: update the latest available version of extensions
              postgresql_ext:
                port: "{{ ports.pg }}"
                db: "{{item.split('.').0}}"
                name: "{{item.split('.').1}}"
                version: latest
              loop: "{{ installed_ext_pangolin }}"

            - name: reinstall pg_repack if it was installed before update
              postgresql_ext:
                port: "{{ ports.pg }}"
                db: "{{item.split('.').0}}"
                name: "{{item.split('.').2}}"
                cascade: yes
                schema: "{{item.split('.').1}}"
              loop: "{{ installed_pg_repack_pangolin }}"

          when: "action_type in ['update_major', 'update_minor']"

        - name: create default roles
          import_tasks: roles.yml

        - debug: msg="{{ update_error_types_breakpoint_msg }}"
          when: is_recovery_test_mode and configure_error_um001m and inventory_hostname == 'master'

        - name: create db objects, if action_type not update
          import_tasks: objects.yml
          when: "'update' not in action_type"

        - name: get list of databases
          postgresql_query:
            port: "{{ ports.pg }}"
            query: SELECT datname FROM pg_database WHERE datname NOT LIKE 'template0'
          register: current_dbs

        - name: create schema for extensions
          import_tasks: create_extensions_schema.yml

        - name: import task for apply search_path_ext sql scripts
          import_tasks: update_apply_sql_scripts.yml
          vars:
            search_path_ext: true
          when: "action_type in ['update_major', 'update_minor']"

        - name: request a list of pgse_backup, pg_pathman, pg_repack, pgstattuple, pg_cron, pg_stat_statements, pg_outline, pg_hint_plan extensions
          postgresql_query:
            port: "{{ ports.pg }}"
            db: postgres
            query: "SELECT extname FROM pg_catalog.pg_extension ex \
                    JOIN pg_namespace ns ON ex.extnamespace =ns.oid \
                    WHERE ex.extname in ('pgse_backup', 'pg_pathman', 'pg_repack', \
                                         'pgstattuple', 'pg_cron', 'pg_stat_statements', 'pg_outline', 'pg_hint_plan');"
          register: query_common_ext_pgse

        - set_fact:
            installed_common_ext_pangolin: []

        - name: define list of pgse_backup, pg_pathman, pg_repack, pgstattuple, pg_cron, pg_stat_statements, pg_outline, pg_hint_plan ext pangolin
          set_fact:
            installed_common_ext_pangolin: "{{ installed_common_ext_pangolin + [item.extname] }}"
          loop: "{{ query_common_ext_pgse.query_result }}"

        - name: create pgse_backup, pg_pathman, pg_repack, pgstattuple extensions
          postgresql_ext:
            name: "{{ item }}"
            schema: ext
            db: postgres
            port: "{{ ports.pg }}"
          loop: [ "pgse_backup", "pg_pathman", "pg_repack", "pgstattuple" ]
          when: "item not in installed_common_ext_pangolin"

        - name: create extensions pg_cron if install
          postgresql_ext:
            name: pg_cron
            schema: ext
            port: "{{ ports.pg }}"
            db: postgres
          when: "'update_major' not in action_type and pg_profile.is_enable and 'pg_cron' not in installed_common_ext_pangolin"

        - name: create extension pg_stat_statements
          postgresql_ext:
            name: pg_stat_statements
            schema: ext
            port: "{{ ports.pg }}"
            db: "{{ item.datname }}"
          with_items: "{{ current_dbs.query_result }}"
          when: "'pg_stat_statements' not in installed_common_ext_pangolin"

        - name: create extensions pg_outline, pg_hint_plan
          postgresql_ext:
            name: "{{ item.0 }}"
            db: "{{ item.1.datname }}"
            port: "{{ ports.pg }}"
          with_nested:
            - [ 'pg_outline', 'pg_hint_plan' ]
            - "{{ current_dbs.query_result }}"
          when: "item.0 not in installed_common_ext_pangolin"

        - name: create extension psql_lockmon
          postgresql_ext:
            name: psql_lockmon
            schema: ext
            db: "{{ item.datname }}"
            port: "{{ ports.pg }}"
            version: latest
          with_items:
            - "{{ current_dbs.query_result }}"
          when: turn_on_or_update_psql_lockmon

        - name: install or update and configure pg_profile
          import_tasks: create_and_configure_pg_profile.yml
          when: pg_profile.is_enable

        - name: install and configure pg_stat_kcache
          import_tasks: create_and_configure_pg_stat_kcache.yml
          when: pg_stat_kcache_is_enable

        - name: GRANT privs to objects
          import_tasks: grants.yml

        - debug: msg="{{ update_error_types_breakpoint_msg }}"
          when: is_recovery_test_mode and configure_error_um002m and inventory_hostname == 'master'

        - name: clearing the password cache for group roles and roles connecting via LDAP
          postgresql_query:
            query: ALTER ROLE "{{ item }}" with password null;
            port: "{{ ports.pg }}"
          with_items:
            - "as_TUZ"
            - "db_admin"
            - "as_admin"
            - "as_admin_read"
            - "all-sa-pam-group"
            - "all-sa-pam19002"
            - "all-sa-pam19002_ro"

        - name: clearing the password cache for as_admins connecting via LDAP when installing
          postgresql_query:
            query: ALTER ROLE "{{ item }}" with password null;
            port: "{{ ports.pg }}"
          with_items: "{{ as_admins }}"
          when: "'update' not in action_type"

        - name: configure pgaudit for group roles
          postgresql_query:
            port: "{{ ports.pg }}"
            query: "{{ item }}"
          with_items:
            - ALTER ROLE "{{ db_admin }}" SET pgaudit.log = 'ddl, role, connection, misc_set, protection';
            - ALTER ROLE "monitoring_php" SET pgaudit.log = 'write, ddl, role, connection, misc_set, protection';
            - ALTER ROLE "auditor" SET pgaudit.log = 'role, read, write, ddl, connection, misc_set, protection';
            - ALTER ROLE "{{ as_group }}" SET pgaudit.log = 'ddl, role, connection, misc_set, protection';
            - ALTER ROLE "zabbix_oasubd" SET pgaudit.log = 'write, ddl, role, connection, misc_set, protection';

        - name: configure pgaudit for backup_user
          postgresql_query:
            port: "{{ ports.pg }}"
            query: "{{ item }}"
          with_items:
            - ALTER ROLE "backup_user" SET pgaudit.log = 'write, ddl, role, connection, misc_set, protection';
          when: SRC

        - name: check {{ as_admins }} role
          postgresql_query:
            port: "{{ ports.pg }}"
            query: SELECT pg_roles.rolname FROM pg_roles WHERE rolname='{{ item }}';
          loop: "{{ as_admins }}"
          register: result_as_admins
          when: "'update' not in action_type"

        - name: configure pgaudit for ldap users - as_admins
          postgresql_query:
            port: "{{ ports.pg }}"
            query: ALTER ROLE "{{ item }}" SET pgaudit.log = 'ddl, role, connection, misc_set, protection';
          loop: "{{ as_admins }}"
          loop_control:
            index_var: index
          when: "'update' not in action_type and result_as_admins.results[ index ].rowcount == 1"

        - name: delete pgbouncer user and all his objects
          import_tasks: pgbouncer.yml
          when: "action_type in ['update_major', 'update_minor']"

        - name: copy grants script to master
          template:
            src: 'grants_on_functions.sql.j2'
            dest: '{{ REMOTE_TMP }}/grants_on_functions.sql'
            owner: postgres
            group: postgres
            mode: 0644

        - name: grants on functions postgres
          postgresql_query:
            port: "{{ ports.pg }}"
            path_to_script: "{{ REMOTE_TMP }}/grants_on_functions.sql"
            db: "{{ item.datname }}"
          with_items: "{{ current_dbs.query_result }}"

      run_once: true
      environment: "{{ db_connection_args }}"
      become: true
      become_user: postgres
      when: ansible_fqdn == current_master

    - name: check if diuid var exists
      debug: msg="Stand will not set up to monitoring because of diuid var is undefined. \
                  Please set up to monitoring manually by folowing instruction \
                  https://sbtatlas.sigma.sbrf.ru/wiki/pages/viewpage.action?pageId=2310838234#id-%D0%98%D0%BD%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%86%D0%B8%D1%8F%D0%BF%D0%BE%D0%B8%D0%BD%D1%81%D1%82%D0%B0%D0%BB%D1%8F%D1%86%D0%B8%D0%B8PostgreSQLSberEdition%D0%B4%D0%BB%D1%8F%D0%B2%D1%81%D0%B5%D1%85%D1%81%D1%80%D0%B5%D0%B4%D0%BF%D0%BElegacy%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81%D1%83-%D0%A1%D0%BE%D0%B7%D0%B4%D0%B0%D0%BD%D0%B8%D0%B5%D0%97%D0%9D%D0%9E%D0%BD%D0%B0%D0%BF%D0%BE%D1%81%D1%82%D0%B0%D0%BD%D0%BE%D0%B2%D0%BA%D1%83%D0%BD%D0%B0%D0%BC%D0%BE%D0%BD%D0%B8%D1%82%D0%BE%D1%80%D0%B8%D0%BD%D0%B3%D0%BD%D0%B0%D0%BA%D0%BE%D0%BC%D0%B0%D0%BD%D0%B4%D1%83SberInfra"
      when: "diuid is undefined"

    - name: install monitoring
      import_tasks: monitoring.yml
      when: "monitoring_zabbix is defined and monitoring_zabbix and diuid is defined"

    - debug: msg="{{ update_error_types_breakpoint_msg }}"
      when: is_recovery_test_mode and configure_error_um003m and inventory_hostname == 'master'

  when: inventory_hostname == 'master'

  rescue:

    - name: set python interpretator
      set_fact:
        ansible_python_interpreter: '{{ python.global_bin_2 }}'

    - name: replica updated with error
      set_fact:
        update_errors: "{{ update_errors|combine(data, recursive=True) }}"
        cacheable: yes
      vars:
        data:
          aggregate: true
          hosts:
            replica: true
          components:
            configuration: true
          types:
            configuration:
              main: true
      run_once: true
      when: inventory_hostname == 'replica'

    - name: master updated with error
      set_fact:
        update_errors: "{{ update_errors|combine(data, recursive=True) }}"
        cacheable: yes
      vars:
        data:
          aggregate: true
          hosts:
            master: true
          components:
            configuration: true
          types:
            configuration:
              main: true
      run_once: true
      when: inventory_hostname == 'master'
      
  always:

    - name: unblock traffic for {{ PGPORT_OLD }}
      include_role:
        name: common
        tasks_from: block_traffic
      vars:
        block_traffic: false
        the_current_haproxy_port: "{{ ports.haproxy }}"
        the_current_pgbouncer_port: "{{ ports.pgbouncer }}"
        the_current_pg_port: "{{ ports.pg }}"
      when: "is_downtime_configure_module \
             and action_type == 'update_minor'"

    - name: to stop install process if error
      fail: msg='Install process must be stopped by error'
      when: "action_type == 'install' and \
            hostvars['master' or 'replica'].update_errors.aggregate"

- name: Set python interpretator
  set_fact:
    ansible_python_interpreter: '{{ python.global_bin_2 }}'
