- name: Import task for test local connect for postgres
  import_tasks: check_postgres_db_connection.yml

- name: Define version of current python interpreter
  set_fact:
    previous_python_interpreter: "{{ ansible_python_interpreter }}"

- name: Set python interpretator
  set_fact:
    ansible_python_interpreter: '{{ python.postgresql_venv }}/bin/python3'

- name: Check pgdata
  block:

    - name: get current major version
      set_fact:
        current_major_version: "{{ pg_current_version.split('.').0 }}"

    - name: set pgdata_should_be depending on the version
      set_fact:
        pgdata_should_be: "{% if ( [ pg_current_version, '4.3.0' ] | compare_pg_se_versions )|int == 0 %}/pgdata/11/data\ 
                           {% else %}/pgdata/{{ current_major_version }}/data{% endif %}"

    - name: data_directory request from DBMS
      postgresql_query:
        port: "{{ PGPORT_OLD }}"
        query: SHOW data_directory;
      register: query_current_data_directory

    - name: adding an error to the scout_error_list if /pgdata/<version>/data is PGDATA
      set_fact:
        scout_error_list: "{{ scout_error_list + [item] }}"
      no_log: "{{ nolog }}"
      with_items:
        - "{{ scout_control_msgs.fails.incorrect_pgdata_location \
              | replace('pgdata_real',query_current_data_directory.query_result.0.data_directory) \
              | replace('pgdata_should_be',pgdata_should_be) }}"
      when: query_current_data_directory.query_result.0.data_directory != pgdata_should_be

  environment: "{{ db_connection_args }}"
  become: true
  become_user: postgres

- name: Check pgdata directory structure
  block:

    - name: define list_dir
      set_fact:
        list_dir: []

    - name: get list directory in pgdata_old
      find:
        paths: "{{ PGDATA_OLD }}"
        recurse: yes
        file_type: directory
      register: list_dir_out

    - name: redefine list_dir
      set_fact:
        list_dir: "{{ (list_dir + [item.path]) | sort}} "
      with_items:
        - "{{ list_dir_out.files }}"
      when: "'pg_replslot' not in item.path \
              and 'pg_backup_restore' not in item.path \
              and 'pgsql_tmp' not in item.path \
              and 'pg_logical' not in item.path \
              and 'pg_wal' not in item.path"

    - name: pgdata directory structure
      debug:
        msg: "{{ list_dir }}"

    - name: adding an error to the scout_error_list_assert if incorrect pgdata directory structure
      set_fact:
        scout_error_list_assert: "{{ scout_error_list_assert + [item] }}"
      no_log: "{{ nolog }}"
      with_items:
        - "{{ scout_control_msgs.fails.incorrect_pgdata_directory_structure }}"
      when: hostvars['master'].list_dir != hostvars['replica'].list_dir

    - name: print message if incorrect pgdata directory structure
      assert:
        that: hostvars['master'].list_dir == hostvars['replica'].list_dir
        fail_msg: "incorrect pgdata directory structure"

  become: true
  become_user: postgres
  when: installation_type == 'cluster'

- name: Check symlinks in pgdata
  block:

    - name: define list_symlinks_files
      set_fact:
        list_symlinks_files: []
        list_symlinks_link_source: []

    - name: get list symlinks in pgdata_old
      find:
        paths: "{{ PGDATA_OLD }}"
        recurse: yes
        file_type: link
      register: list_symlinks_files_out

    - name: get simlink parameters
      stat:
        path: "{{ item.path }}"
      register: list_symlinks_parameters_out
      with_items:
        - "{{ list_symlinks_files_out.files }}"

    - name: redefine list_symlinks_files
      set_fact:
        list_symlinks_files: "{{ list_symlinks_files + [item.item.path] }}"
        list_symlinks_link_source: "{{ list_symlinks_link_source + [item.stat.lnk_source] }}"
      with_items:
        - "{{ list_symlinks_parameters_out.results }}"

    - name: set dict symlinks_journal
      set_fact:
        symlinks_journal: "{{ dict(list_symlinks_files | zip(list_symlinks_link_source)) }}"

    - name: symlinks in pgdata
      debug:
        msg: "{{ symlinks_journal }}"

    - name: adding an error to the scout_error_list_assert if the symlinks differ
      set_fact:
        scout_error_list_assert: "{{ scout_error_list_assert + [item] }}"
      no_log: "{{ nolog }}"
      with_items:
        - "{{ scout_control_msgs.fails.symlinks_pgdata_different }}"
      when: hostvars['master'].symlinks_journal != hostvars['replica'].symlinks_journal

    - name: print message if the symlinks differ
      assert:
        that: hostvars['master'].symlinks_journal == hostvars['replica'].symlinks_journal
        fail_msg: "the symlinks differ"

  become: true
  become_user: postgres
  when: installation_type == 'cluster'

- name: Check SRC component
  block:

    - name: if src files exist but user decided not update
      debug:
        msg: "{{ scout_control_msgs.warnings.src_defined_and_user_not_decided_update }}"
      when: SRC is defined and not SRC and is_src_exists

    - name: check that src files exist but user not decided about update
      debug:
        msg: "{{ scout_control_msgs.fails.user_not_decided_about_src_update }}"
      when: SRC is undefined and is_src_exists

    - name: user decided update src, but src files not exist
      debug:
        msg: "{{ scout_control_msgs.fails.user_decided_src_update_but_src_not_installed }}"
      when: SRC is defined and SRC and not is_src_exists

    - name: user decided update src, but src files exists and not correct
      debug:
        msg: "{{ scout_control_msgs.fails.user_decided_src_update_but_src_not_correct_installed }}"
      when: SRC is defined and SRC and is_src_exists and is_src_exists_and_not_correct

  when: inventory_hostname != 'etcd'

- name: Run scout scripts
  block:

    - name: check the existence of data in the public schema exist and check extensions that are not part of pgse
      block:

        - name: request to get all databases
          postgresql_query:
            port: "{{ PGPORT_OLD }}"
            query: SELECT datname FROM pg_database WHERE datallowconn;
          register: query_all_database

        - name: check the existence of data in the public schema exist
          block:

            - name: request to get data in the public schema
              postgresql_query:
                port: "{{ PGPORT_OLD }}"
                db: "{{ item.datname }}"
                query: "SELECT format('{{ item.datname }}.%1$s.%2$s',table_schema,table_name) data_public FROM information_schema.tables \
                        WHERE table_schema = 'public' AND table_name NOT LIKE 'pathman%' AND table_name NOT LIKE 'pg_stat_state%';"
              register: query_data_public
              with_items: "{{ query_all_database.query_result }}"

            - name: wrong extensions
              set_fact:
                data_public: "{{ query_data_public.results|
                                 map('dict2items')|list|flatten|
                                 json_query('[?key==`query_result`].value')|flatten|
                                 map('dict2items')|list|
                                 json_query('[*][?key==`data_public`].value')|flatten|
                                 join(', ') }}"

            - name: print warnings if data_public
              debug:
                msg: "{{ scout_control_msgs.warnings.data_public | replace('table_name',data_public) }}"
              when: data_public|length != 0

        - name: Check extension correct installed for pg_profile
          block:

            - name: check pg_stat_statements and pg_hint_plan for all db
              postgresql_query:
                query: SELECT extname FROM pg_extension WHERE extname LIKE 'pg_stat_statements' OR extname LIKE 'pg_hint_plan';
                port: "{{ PGPORT_OLD }}"
                db: "{{ item.datname }}"
              with_items: "{{ query_all_database.query_result }}"
              register: _extension_installed_all_database

            - name: save dict format extension installed in all database
              set_fact:
                pg_stat_statements_in_db: "{{ pg_stat_statements_in_db | default({}) | combine({item.item.datname: 'pg_stat_statements' in item.query_result | map(attribute='extname') | list}) }}"
                pg_hint_plan_in_db: "{{ pg_hint_plan_in_db | default({}) | combine({item.item.datname: 'pg_hint_plan' in item.query_result | map(attribute='extname') | list}) }}"
              with_items: "{{ _extension_installed_all_database.results }}"

            - name: adding an error to the scout_error_list if pg_stat_statements install any base and not installed all base
              set_fact:
                scout_error_list: "{{ scout_error_list + [scout_control_msgs.fails.pg_stat_statements_all_base | replace('database_name', item) ] }}"
              no_log: "{{ nolog }}"
              with_items: "{{ pg_stat_statements_in_db }}"
              when: "{{ pg_stat_statements_in_db.values() | list | filter_any }} and not {{ pg_stat_statements_in_db[item] }}"

            - name: adding an error to the scout_error_list if pg_hint_plan install any base and not installed all base
              set_fact:
                scout_error_list: "{{ scout_error_list + [scout_control_msgs.fails.pg_hint_plan_all_base | replace('database_name', item) ] }}"
              no_log: "{{ nolog }}"
              with_items: "{{ pg_hint_plan_in_db }}"
              when: "{{ pg_hint_plan_in_db.values() | list | filter_any }} and not {{ pg_hint_plan_in_db[item] }}"

            - name: assert if pg_stat_statements install any base and not installed all base
              assert:
                that: "{{ pg_stat_statements_in_db[item] }}"
                fail_msg: "pg_stat_statements not installed in {{ item }}"
              loop_control:
                label: "Database: {{ item }}"
              with_items: "{{ pg_stat_statements_in_db }}"
              when: "{{ pg_stat_statements_in_db.values() | list | filter_any }}"

            - name: assert if pg_hint_plan install any base and not installed all base
              assert:
                that: "{{ pg_hint_plan_in_db[item] }}"
                fail_msg: "pg_hint_plan_in_db not installed in {{ item }}"
              loop_control:
                label: "Database: {{ item }}"
              with_items: "{{ pg_hint_plan_in_db }}"
              when: "{{ pg_hint_plan_in_db.values() | list | filter_any }}"

        - name: check extensions that are not part of Pangolin
          block:

            - name: set additional legal extensions
              set_fact:
                additional_legal_ext: "{% if action_type == 'update_minor' %}, 'timescaledb'\
                                       {% else %}{% endif %}"

            - name: request a list of extensions that are not part of Pangolin
              postgresql_query:
                port: "{{ PGPORT_OLD }}"
                db: "{{ item.datname }}"
                query: "SELECT format('{{ item.datname }}.%1$s.%2$s',nspname,extname) extname FROM pg_catalog.pg_extension ex \
                          JOIN pg_namespace ns ON ex.extnamespace =ns.oid \
                        WHERE ex.extname not in ({{ legal_extensions.third_party }}, {{ legal_extensions.contrib }}{{ additional_legal_ext }});"
              register: query_wrong_ext_pgse
              with_items: "{{ query_all_database.query_result }}"

            - name: wrong ext pgse
              set_fact:
                wrong_ext_pgse: "{{ query_wrong_ext_pgse.results|
                                    map('dict2items')|list|flatten|
                                    json_query('[?key==`query_result`].value')|flatten|
                                    map('dict2items')|list|
                                    json_query('[*][?key==`extname`].value')|flatten|
                                    join(', ') }}"

            - name: print if wrong extension wrong_ext_pgse and action_type == 'update_minor'
              debug:
                msg: "{{ scout_control_msgs.warnings.wrong_ext_pgse | replace('extension_name',wrong_ext_pgse) }}"
              when: wrong_ext_pgse|length != 0 and action_type == 'update_minor'

            - name: adding an error to the scout_error_list if wrong_ext_pgse and action_type == 'update_major'
              set_fact:
                scout_error_list: "{{ scout_error_list + [item] }}"
              no_log: "{{ nolog }}"
              with_items:
                - "{{ scout_control_msgs.fails.missing_ext_pgse | replace('extension_name',wrong_ext_pgse) }}"
              when: wrong_ext_pgse|length != 0 and action_type == 'update_major'

      become_user: postgres
      when: inventory_hostname == 'master'

    - name: run scouting script for checking ports
      shell: netstat -tulpn 2>/dev/null | grep -E "postgres|pgbouncer|haproxy" | awk '{print $4}' | awk -F ":" '{print $2}'
      register: check_ports

    - name: new and old PGPORTs not equal
      debug:
        msg: "{{ scout_control_msgs.warnings.pgport_new_old_not_equal | replace('pgport_old',PGPORT_OLD) }}"
      when: "postgres and ports.pg not in check_ports.stdout"

    - name: new and old pgbouncer ports not equal
      debug:
        msg: "{{ scout_control_msgs.warnings.pgbouncer_new_old_not_equal | replace('pgbouncerport_old',PGBOUNCERPORT_OLD) }}"
      when: "pgbouncer and ports.pgbouncer not in check_ports.stdout"

    - name: new and old haproxy ports not equal
      debug:
        msg: "{{ scout_control_msgs.warnings.haproxy_new_old_not_equal | replace('haproxyport_old',HAPROXYPORT_OLD) }}"
      when: "haproxy and ports.haproxy not in check_ports.stdout"

    - name: show users outside the role model
      block:

        - name: get list of users
          postgresql_query:
            query: SELECT usename FROM pg_user WHERE usesysid != all
              ((SELECT grolist FROM pg_group WHERE groname = 'as_admin') ||
              (SELECT grolist FROM pg_group WHERE groname = 'db_admin') ||
              (SELECT grolist FROM pg_group WHERE groname = 'as_TUZ') ||
              (SELECT grolist FROM pg_group WHERE groname = 'pg_read_all_settings') ||
              (SELECT grolist FROM pg_group WHERE groname = 'as_admin_read') ||
              (SELECT grolist FROM pg_group WHERE groname = 'all-sa-pam-group'))
              AND usename NOT IN ('backup_user', 'postgres', 'auditor', 'pgbouncer', 'pstgcmdb', 
              'masteromni', 'patroni', 'cron', 'profile_tuz', 'sec_admin_backup', 'sec_admin')
            port: "{{ PGPORT_OLD }}"
          register: wrong_users

        - name: define a list of users
          set_fact:
            list_wrong_users: '{{ list_wrong_users | default([]) + [item.usename] }}'
          loop: '{{ wrong_users.query_result }}'

        - name: show wrong users
          debug:
            msg: "{{ control_name }}.WARNING__Пользователь {{ list_wrong_users | join(', ') }} не соответствует ролевой модели. Его настройка произведена не будет__{{ control_name }}.WARNING"
          when: list_wrong_users is defined

        - name: check ldaptls config
          lineinfile:
            name: "{{ PGDATA_OLD }}/pg_hba.conf"
            regexp: ".*ldaptls.*"
            state: absent
          check_mode: yes
          register: _scout_ldaptls_chk

        - name: show warning if ldaptls missed
          debug:
            msg: "{{ scout_control_msgs.warnings.ldap_tls }}"
          register: _scout_ldaptls_chk_msg
          when: not _scout_ldaptls_chk.changed

        - name: fetch pg_hba.conf
          slurp:
            src: "{{ PGDATA_OLD }}/pg_hba.conf"
          register: _scout_pg_hba_conf_file

        - name: define list with md5 rules
          set_fact:
            _scout_md5_users: "{{ _scout_pg_hba_conf_file['content'] | b64decode | regex_findall('.*md5') | reject('search', 'zabbix_oasubd', 'monitoring_php', 'auditor') | list }}__{{ control_name }}"

        - name: show rules with md5
          debug:
            msg: "{{ scout_control_msgs.warnings.md5_rules | replace('scout_md5_rules',_scout_md5_users) }}"
          register: _scout_md5_users_msg
          when: _scout_md5_users|length != 0

        - name: show warning that role model will not actualize
          debug:
            msg: "{{ scout_control_msgs.warnings.role_model }}"
          register: _scout_warning_rm_msg
          when: not cfg_main_roles

        - name: show warning if rsyslog service not available
          debug:
            msg: "{{ scout_control_msgs.warnings.rsyslog }}"
          register: _scout_rsyslog_check_msg
          when: ansible_facts.services['rsyslog.service'].state != 'active'

        - name: add warnings to log file
          lineinfile:
            path: "{{ process_work_statuses.log_file }}"
            insertafter: EOF
            line: "{{ item }}"
            state: present
          become: true
          with_items:
            - "{{ _scout_md5_users_msg.msg | default() }}"
            - "{{ _scout_ldaptls_chk_msg.msg | default() }}"
            - "{{ _scout_rsyslog_check_msg.msg | default() }}"
            - "{{ _scout_warning_rm_msg.msg | default() }}"
          when: item is defined

      become_user: postgres
      when: inventory_hostname == 'master'

    - name: check user and script for data protector integration
      block:

        - name: find path to manage_backup sh file
          find:
            paths: "{{ manage_backup_bin }}"
            use_regex: yes
            patterns:  '^[\d]*\_manage_backup\.sh'
          register: manage_backup_file

        - name: define variable with path to manage_backup sh file
          set_fact:
            path_to_manage_backup_sh_file: "{{ manage_backup_file['files'][0].path }}"
          when: manage_backup_file.matched == 1

        - name: set variables with status of backup_user
          set_fact:
            backup_user_is_using_in_file: false
            backup_user_exists_in_db: false

        - name: get info about users from db
          postgresql_query:
            query: "SELECT * FROM pg_user"
            port: "{{ PGPORT_OLD }}"
          register: backup_user_query

        - name: redefine backup_user_exists_in_db variable if user exists
          set_fact:
            backup_user_exists_in_db: true
          loop: "{{ backup_user_query.query_result }}"
          when: "item.usename == 'backup_user'"

        - name: get content from mahage_backup.sh file and check user in content
          block:

            - name: check that mahage_backup.sh file is exists
              stat:
                path: "{{ path_to_manage_backup_sh_file }}"
              register: manage_backup_sh_file_is_exists

            - name: adding an error to the scout_error_list_assert if manage_backup sh file not exist
              set_fact:
                scout_error_list_assert: "{{ scout_error_list_assert + [item] }}"
              no_log: "{{ nolog }}"
              run_once: true
              with_items:
                - "{{ scout_control_msgs.fails.manage_backup_sh_is_not_exists }}"
              when: not manage_backup_sh_file_is_exists.stat.exists

            - name: print message if manage_backup sh file not exist
              assert:
                that: manage_backup_sh_file_is_exists.stat.exists
                fail_msg: "manage_backup sh file not exist"
              run_once: true

            - name: print content of file and register it into variable
              command:
                cmd: "cat {{ path_to_manage_backup_sh_file }}"
              register: content_of_sh_file
              no_log: "{{ nolog }}"
              become_user: root
              when: manage_backup_sh_file_is_exists.stat.exists

            - name: check that backup_user is using in manage_backup.sh file
              set_fact:
                backup_user_is_using_in_file: "{{ content_of_sh_file.stdout | check_backup_user_in_file }}"

          when: backup_user_exists_in_db

        - name: adding an error to the scout_error_list_assert if backup_user doesn't exists
          set_fact:
            scout_error_list_assert: "{{ scout_error_list_assert + [item] }}"
          no_log: "{{ nolog }}"
          run_once: true
          with_items:
            - "{{ scout_control_msgs.fails.backup_user_doesnt_exists }}"
          when: not backup_user_exists_in_db and not backup_user_is_using_in_file

        - name: print message if backup_user doesn't exists
          assert:
            that: backup_user_exists_in_db and backup_user_is_using_in_file
            fail_msg: "backup_user doesn't exists"
          run_once: true

        - name: check state SRC session
          block:
            
            - name: get status information from backup.history
              postgresql_query:
                port: "{{ PGPORT_OLD }}"
                query: SELECT state FROM backup.history ORDER BY start_time DESC LIMIT 1;
              register: current_state_src

            - name: adding an error to the scout_error_list if RC started
              set_fact:
                scout_error_list: "{{ scout_error_list + [item] }}"
              no_log: "{{ nolog }}"
              with_items:
                - "{{ update_control_msgs.fails.update_component_src_status_fail }}"
              when: "current_state_src.query_result != [] and \
                     current_state_src.query_result[0].state not in ['completed','failed','waiting_for_wal_backup']"

      become_user: postgres
      when: SRC

    - name: check duplicates params in config files
      block:

        - name: get duplicates info
          reciter:
            ANSIBLE_MODULE_ARGS:
              src: "{{ patroni_files.conf_dir }}/postgres.yml"
              action: check_duplies
          register: check_info
          environment:
            - PYTHONPATH: "{{ python.postgresql_venv_packages }}"

        - name: adding an error to the scout_error_list_assert if duplicates params in config files
          set_fact:
            scout_error_list_assert: "{{ scout_error_list_assert + [item] }}"
          no_log: "{{ nolog }}"
          run_once: true
          with_items:
            - "{{ scout_control_msgs.fails.duplicates_error }}"
          when: not check_info.message

        - name: print message if duplicates params in config files
          assert:
            that: check_info.message
            fail_msg: "duplicates params in config files"
          run_once: true

      when: patroni

  environment: "{{ db_connection_args }}"
  become: true
  when: ssl_error is not defined

- name: Сheck unicode symbols in config files
  block:

    - name: fetch config files from hosts
      fetch:
        src : "{{ item }}"
        dest: "{{ playbook_dir }}"
      with_items:
        - "{{ PGDATA_OLD }}/pg_hba.conf"
        - "{{ PGDATA_OLD }}/postgresql.conf"
        - "{% if patroni %}{{ patroni_files.conf_dir }}/postgres.yml{% endif %}"
      become: true
      when: item != ''

    - name: check unicode symbols in configs
      assert:
        that:  '{{ item.copy_file | check_configs_on_unsupported_symbols }}'
        fail_msg: "RLM.FAIL__В файле {{ item.file}} найден символ unicode, необходимо скорректировать конфигурационный файл__RLM.FAIL"
      with_items:
        - { copy_file: "{{ playbook_dir }}/{{inventory_hostname}}{{ PGDATA_OLD }}/pg_hba.conf",file: "{{ PGDATA_OLD }}/pg_hba.conf" }
        - { copy_file: "{{ playbook_dir }}/{{inventory_hostname}}{{ PGDATA_OLD }}/postgresql.conf",file: "{{ PGDATA_OLD }}postgresql.conf"}
        - { copy_file:  "{% if patroni %}{{ playbook_dir }}/{{inventory_hostname}}{{ patroni_files.conf_dir }}/postgres.yml{% endif %}",
                  file: "{% if patroni %}{{ patroni_files.conf_dir }}/postgres.yml{% endif %}"}
      when: item.copy_file != ''

    - name: remove temp files for check spec symbols
      file:
        path: '{{ item }}'
        state: absent
      delegate_to: localhost
      with_items:
        - "{{ playbook_dir }}/{{ inventory_hostname }}{{ PGDATA_OLD }}"
        - "{%if patroni %}{{ playbook_dir }}/{{ inventory_hostname }}/{{ patroni_files.conf_dir }}{% endif %}"

- name: Write to stdout about ssl error
  debug:
    msg: "{{ ssl_error }}"
  when: ssl_error is defined

- name: Set python interpretator
  set_fact:
    ansible_python_interpreter: '{{ previous_python_interpreter }}'
