- name: Unlock OS postgres user
  shell: "chage {{ item }} -1 postgres"
  with_items:
    - "-E"
    - "-M"
    - "-I"
  become: true

- name: Run main scout
  block:

    - name: include update variables
      include_vars:
        file: "group_vars/update.yml"
      no_log: "{{ nolog }}"

    - name: include update variables
      include_vars:
        file: "group_vars/message.yml"
      no_log: "{{ nolog }}"

    - name: check and use custom_config
      include_role:
        name: checkup
        tasks_from: check_and_use_custom_config

    - name: define scout_error_list/scout_error_list_assert/scout_scenario_error/action_type/package_error/error_list
      set_fact:
        action_type: "update"
        scout_error_list: []
        scout_error_list_assert: []
        scout_scenario_error: false
        package_error: []
        error_list: ''

    - name: set pg_version
      include_role:
        name: checkup
        tasks_from: find_package

    - name: check ansible environment
      include_role:
        name: checkup
        tasks_from: ansible_env

    - name: check KillUserProcesses
      lineinfile:
        dest: /etc/systemd/logind.conf
        line: KillUserProcesses=yes
      register: _kill_user_processes
      check_mode: true
      become: true

    - name: adding an error to the scout_error_list_assert if disallow_update_file_exists.stat.exists
      set_fact:
        scout_error_list_assert: "{{ scout_error_list_assert + [item] }}"
      no_log: "{{ nolog }}"
      with_items:
        - "{{ message_installer.fails.kill_user_process_on | replace('host_name', inventory_hostname) }}"
      when: not _kill_user_processes.changed

    - name: assert if KillUserProcesses not change
      assert:
        that: _kill_user_processes.changed
        fail_msg: "KillUserProcesses=yes exist need remove and reboot system"

    - name: check exists disallow update_file as {{ update_status_files.disallow_update }}
      stat: path="{{ update_status_files.disallow_update }}"
      register: disallow_update_file_exists
      become: true
      run_once: true

    - name: check exists trigger update file {{ update_status_files.dir }}/.trigger_stop_update
      stat: path="{{ update_status_files.dir }}/.trigger_stop_update"
      register: trigger_update_file_exists
      become: true
      when: inventory_hostname == 'master'

    - name: remove temp file if exists
      block:

        - name: remove file trigger if exists
          file:
            path: "{{ update_status_files.dir }}/.trigger_stop_update"
            state: absent
          when: trigger_update_file_exists.stat.exists

        - name: print message successfully remove file
          debug:
            msg: "{{ scout_control_msgs.info.remove_trigger_file }}"
          register: remove_trigger_file
          when: trigger_update_file_exists.stat.exists

        - name: remove file disallow_update_file
          file:
            path: "{{ update_status_files.disallow_update }}"
            state: absent
          when: disallow_update_file_exists.stat.exists

        - name: print message successfully remove file
          debug:
            msg: "{{ scout_control_msgs.info.remove_disallow_update_file }}"
          register: remove_disallow_update_file
          when: disallow_update_file_exists.stat.exists

        - name: add warnings to log file
          lineinfile:
            path: "{{ process_work_statuses.log_file }}"
            insertafter: EOF
            line: "{{ item }}"
            state: present
            create: true
          become: true
          with_items:
            - "{{ remove_trigger_file.msg | default() }}"
            - "{{ remove_disallow_update_file.msg | default() }}"
          when: item is defined

      become: true
      when: inventory_hostname == 'master' and remove_block_update_tmp_files

    - name: adding an error to the scout_error_list_assert if disallow_update_file_exists.stat.exists
      set_fact:
        scout_error_list_assert: "{{ scout_error_list_assert + [item] }}"
      no_log: "{{ nolog }}"
      run_once: true
      with_items:
        - "{{ scout_control_msgs.fails.update_file_exists }}"
      when: disallow_update_file_exists.stat.exists and not remove_block_update_tmp_files

    - name: print message if {{ update_status_files.disallow_update }} exists
      assert:
        that: not disallow_update_file_exists.stat.exists
        fail_msg: "disallow_update_file_exists.stat.exists"
      run_once: true
      when: not remove_block_update_tmp_files

    - name: adding an error to the scout_error_list_assert if trigger_update_file_exists.stat.exists
      set_fact:
        scout_error_list_assert: "{{ scout_error_list_assert + [item] }}"
      no_log: "{{ nolog }}"
      run_once: true
      with_items:
        - "{{ scout_control_msgs.fails.trigger_update_file_exists }}"
      when: trigger_update_file_exists.stat.exists and not remove_block_update_tmp_files

    - name: print message if {{ update_status_files.dir }}/.trigger_stop_update exists
      assert:
        that: not trigger_update_file_exists.stat.exists
        fail_msg: "trigger_update_file_exists.stat.exists"
      run_once: true
      when: not remove_block_update_tmp_files

    - name: print INFO message third_party_backup if is_inner_full_backup = false
      debug:
        msg: "{{ scout_control_msgs.info.third_party_backup }}"
      run_once: true
      when: not is_inner_full_backup

    - name: check remote linux environment
      block:

        - name: check remote linux environment
          include_role:
            name: checkup
            tasks_from: linux_env

        - name: check linux package in yum repo
          shell: "{% if ansible_os_family == 'Altlinux' %}apt-cache show {{ item.name }} | grep {{ item.ver }}{% else %}yum list {{ item.name }}-{{ item.ver }}{% endif %}"
          with_items:
            - { name: "etcd", ver: "{{ versions.etcd }}" , condition: "'etcd' in ansible_facts.packages" }
            - { name: "haproxy", ver: "{{ versions.haproxy }}", condition: "'haproxy' in ansible_facts.packages" }
          register: list_of_package_error
          when: "{{ item.condition }}"

      ignore_errors: true

    - name: add the packages name to the package_error list
      set_fact:
        package_error: "{{ package_error + [result_install_list.results[index].item] }}"
      with_items: "{{ result_install_list.results }}"
      loop_control:
        index_var: index
      when: "result_install_list is defined \
            and result_install_list.results[index].failed"

    - name: update package_error list if need
      set_fact:
        package_error: "{{ package_error + [list_of_package_error.results[index].item.name] }}"
      with_items: "{{ list_of_package_error.results }}"
      loop_control:
        index_var: index
      when: "list_of_package_error is defined \
            and list_of_package_error.results[index].stdout is defined \
            and ((list_of_package_error.results[index].stdout.find('No matching Packages to list') != -1 \
            or (list_of_package_error.results[index].rc is defined \
            and list_of_package_error.results[index].rc == 1)))"

    - name: add a warning message
      set_fact:
        error_list: "{{ error_list }}{% for host in item[index] %}{% if hostvars[item].package_error != [] %}на {{ item }}: {{ hostvars[item].package_error | join(', ') }}{% if installation_type == 'cluster' and index != 2 %}; {% endif %}{% endif %}{% endfor %}"
      loop: "{{ groups['all'] }}"
      loop_control:
        index_var: index
      run_once: true

    - name: adding an error to the scout_error_list_assert if found error when download packages
      set_fact:
        scout_error_list_assert: "{{ scout_error_list_assert + [item] }}"
      no_log: "{{ nolog }}"
      run_once: true
      with_items:
        - "{{ scout_control_msgs.fails.incorrect_repo }}"
      when: error_list != ''

    - name: print message if found error when download packages
      assert:
        that: error_list == ''
        fail_msg: "Found error the process of downloading packages"
      run_once: true

    - name: redefining variables for the location of the python venv
      set_fact:
        python: "{{ python|combine(data, recursive=True) }}"
      vars:
        data:
          postgresql_venv: "{{ REMOTE_TMP }}/postgresql_venv"
          postgresql_venv_packages: "{{ REMOTE_TMP }}/postgresql_venv/lib/python3/site-packages:\
                                     {{ REMOTE_TMP }}/postgresql_venv/lib64/python3/site-packages:\
                                     {{ REMOTE_TMP }}/postgresql_venv/lib/python3.6/site-packages:\
                                     {{ REMOTE_TMP }}/postgresql_venv/lib64/python3.6/site-packages"

    - name: include task file for install python venv for ansible use
      include_role:
        name: checkup
        tasks_from: python_env

    - name: check that inventory master is same master from SM
      include_role:
        name: checkup
        tasks_from: define_current_master

    - name: define current master role of the cluster
      include_role:
        name: patroni
        tasks_from: update_define_roles_of_nodes.yml

    - name: prepare update
      include_role:
        name: checkup
        tasks_from: prepare_update.yml
      vars:
        PGHOME: "{{ PGHOME_OLD }}"

    - name: adding an error to the scout_error_list_assert if the version is less than the minimum supported version
      set_fact:
        scout_error_list_assert: "{{ scout_error_list_assert + [item] }}"
      no_log: "{{ nolog }}"
      run_once: true
      with_items:
        - "{{ scout_control_msgs.fails.unsupported_version_number 
              | replace('pg_current_version',pg_current_version) 
              | replace('min_actual_pangolin_ver',min_actual_pangolin_ver)}}"
      when: ( [ pg_current_version, min_actual_pangolin_ver ] | compare_pg_se_versions )|int == 0

    - name: print message if the version is less than the minimum supported version
      assert:
        that: ( [ pg_current_version, min_actual_pangolin_ver ] | compare_pg_se_versions )|int != 0
        fail_msg: "The current version is less than the minimum supported {{ min_actual_pangolin_ver }}"
      run_once: true

    - name: adding an error to the scout_error_list_assert if the type of installed configuration is not supported
      set_fact:
        scout_error_list_assert: "{{ scout_error_list_assert + [item] }}"
      no_log: "{{ nolog }}"
      run_once: true
      with_items:
        - "{{ scout_control_msgs.fails.not_support_type_installed_configuration | replace('tag',tag) }}"
      when: "tag in not_support_type_installed_configuration"

    - name: print message if the type of installed configuration is not supported
      assert:
        that: tag not in not_support_type_installed_configuration
        fail_msg: "Type of installed configuration ({{ tag }}) is not supported"
      run_once: true

    - name: check encrypt space with actual user passwords
      block:

        - name: check if pg_auth_config exists
          stat:
            path: "{{ PGHOME_OLD }}/bin/pg_auth_config"
          register: pg_auth_config_exists

        - name: check encrypt space with actual user passwords if pg_auth_config_exists
          shell: "{{ PGHOME_OLD }}/bin/pg_auth_config check"
          register: result_check
          until: result.stdout.find("FATAL") == -1
          retries: 5
          environment:
            PG_PLUGINS_PATH: "{{ PGHOME_OLD }}/lib"
          ignore_errors: yes
          when: pg_auth_config_exists.stat.exists

        - name: adding an error to the scout_error_list_assert if 'FATAL' in result_check.stdout
          set_fact:
            scout_error_list_assert: "{{ scout_error_list_assert + [item] }}"
          no_log: "{{ nolog }}"
          run_once: true
          with_items:
            - "{{ scout_control_msgs.fails.pg_auth_config_check }}"
          when: "pg_auth_config_exists.stat.exists and 'FATAL' in result_check.stdout"

        - name: print message if 'FATAL' in result_check.stdout
          assert:
            that: "'FATAL' not in result_check.stdout"
            fail_msg: "pg_auth_config check failed"
          run_once: true
          when: pg_auth_config_exists.stat.exists

      become: true
      become_user: postgres
      when: inventory_hostname != 'etcd'

    - name: get update type and set variable action_type/pg_upgrade_mode
      include_role:
        name: update_scout
        tasks_from: get_update_type.yml
      when: inventory_hostname != 'etcd'

    - name: write to process status work that scout process started
      include_role:
        name: common
        tasks_from: add_process_status_logs
      vars:
        process_work_status: "{{ process_work_statuses.scout.start }}"
        scout_key: true

    - name: formation and printing in the log ARGS
      block:

        - name: set args_parameters
          set_fact:
            args_parameters:
              update_complexity_level: "{% if action_type == 'update_minor' %}\
                                          update_complexity_level_1\
                                        {% elif action_type == 'update_major' and  pg_upgrade_mode == 'hardlink'%}\
                                          update_complexity_level_2\
                                        {% elif action_type == 'update_major' and  pg_upgrade_mode != 'hardlink'%}\
                                          update_complexity_level_3\
                                        {% endif %}"

        - name: modification args_parameters
          set_fact:
            args_parameters: "{{ args_parameters | to_json}}"

        - name: print args_parameters
          debug:
            msg: "{{ scout_control_msgs.args.args_parameters | replace('args_parameters',args_parameters) }}"
          run_once: true

    - name: check physical space on directories/mount points
      include_role:
        name: checkup
        tasks_from: check_physical_space_on_directories_or_mount_points

    - name: check file system type for PGDATA/PGDATA_OLD/PGBACKUP/local_backup_path
      block:

        - name: get file system type for PGDATA/PGDATA_OLD/PGBACKUP/local_backup_path
          shell: "df -Th | grep \"^$(df {{ item }} | tail -1 | awk '{print $1}')\" | awk '{print $2}'"
          register: file_system_type_for_directories
          with_items:
            - "/{{ PGDATA.split('/')[1] }}"
            - "{{ PGDATA_OLD }}"
            - "/{{ PGBACKUP.split('/')[1] }}"
            - "{{ local_backup_path }}"

        - name: adding an error to the scout_error_list_assert if different type of file system for PGDATA/PGDATA_OLD/PGBACKUP/local_backup_path
          set_fact:
            scout_error_list_assert: "{{ scout_error_list_assert + [item] }}"
          no_log: "{{ nolog }}"
          with_items:
            - "{{ scout_control_msgs.fails.different_type_of_file_system 
                  | replace('pgdata_old_file_system_type',file_system_type_for_directories.results.0.stdout)
                  | replace('pgdata_file_system_type',file_system_type_for_directories.results.1.stdout)
                  | replace('pgbackup_file_system_type',file_system_type_for_directories.results.2.stdout)
                  | replace('local_backup_path_file_system_type',file_system_type_for_directories.results.3.stdout) }}"
          when: file_system_type_for_directories.results.0.stdout != file_system_type_for_directories.results.1.stdout or 
                file_system_type_for_directories.results.0.stdout != file_system_type_for_directories.results.2.stdout or 
                file_system_type_for_directories.results.0.stdout != file_system_type_for_directories.results.3.stdout

        - name: print message if different type of file system for PGDATA/PGDATA_OLD/PGBACKUP/local_backup_path
          assert:
            that: file_system_type_for_directories.results.0.stdout == file_system_type_for_directories.results.1.stdout and 
                  file_system_type_for_directories.results.0.stdout == file_system_type_for_directories.results.2.stdout and 
                  file_system_type_for_directories.results.0.stdout == file_system_type_for_directories.results.3.stdout
            fail_msg: "Different type of file system for PGDATA({{ file_system_type_for_directories.results.0.stdout }}), \
                       PGDATA_OLD({{ file_system_type_for_directories.results.1.stdout }}), \
                       PGBACKUP({{ file_system_type_for_directories.results.2.stdout }}), \
                       local_backup_path({{ file_system_type_for_directories.results.3.stdout }})"

      become: true
      when: action_type == 'update_major' and pg_upgrade_mode == "hardlink" and ansible_fqdn == current_master

    - name: scout servers for all update types
      import_tasks: 'scout.yml'
      when: "'update' in action_type and inventory_hostname != 'etcd'"

    - name: scout of only major update type
      import_tasks: 'scout_major.yml'
      when: action_type == 'update_major'

    - name: delete backup dir with hda configs
      file:
        path: "{{ _preupdatecerts_backup_hba_cfgs }}"
        state: absent
      become: true
      when: inventory_hostname != 'etcd'

  rescue:

    - name: redefine variable scout_scenario_error
      set_fact:
        scout_scenario_error: true

    - name: print scout_error_list_assert
      debug:
        msg: "{{ scout_error_list_assert | join(' ; ') }}"
      run_once: true

    - name: print if unexpected error
      debug:
        msg: "{{ scout_control_msgs.fails.unexpected }}"
      run_once: true
      when: scout_error_list_assert|length == 0

    - name: set scout_scenario_error_unexpected if unexpected error
      set_fact:
        scout_scenario_error_unexpected: true
      when: scout_error_list_assert|length == 0

  always:

    - name: print scout_error_list
      block:

        - name: save all error for cluster
          set_fact:
            scout_error_list: "{{ hostvars['master'].scout_error_list + hostvars['replica'].scout_error_list + hostvars['etcd'].scout_error_list }}"
          no_log: "{{ nolog }}"
          when: installation_type == 'cluster'

        - name: print scout_error_list
          debug:
            msg: "{{ scout_error_list | join(' ; ') }}"
          when: scout_error_list|length > 0

        - name: print INFO estimation_update_execution_time message if the scout scenario is executed successfully
          debug:
            msg: "{% if (installation_type == 'standalone' and not scout_scenario_error and scout_error_list|length == 0)
                        or (installation_type == 'cluster' \
                            and not hostvars['master'].scout_scenario_error \
                            and not hostvars['replica'].scout_scenario_error \
                            and not hostvars['etcd'].scout_scenario_error) \
                            and scout_error_list|length == 0 \
                  %}{{ control_name }}.INFO__{{ estimation_update_execution_time }}__{{ control_name }}.INFO
                  {% endif %}"
          when: "estimation_update_execution_time is defined and estimation_update_execution_time|length > 0"

        - name: print if the scout scenario is executed successfully
          debug:
            msg: "{% if (installation_type == 'standalone' and not scout_scenario_error and scout_error_list|length == 0)
                        or (installation_type == 'cluster' \
                            and not hostvars['master'].scout_scenario_error \
                            and not hostvars['replica'].scout_scenario_error \
                            and not hostvars['etcd'].scout_scenario_error) \
                            and hostvars['master'].scout_error_list|length == 0 \
                            and hostvars['replica'].scout_error_list|length == 0 \
                            and hostvars['etcd'].scout_error_list|length == 0 \
                  %}{{ scout_control_msgs.ok.scout_successfully }}
                  {% endif %}"
      run_once: true