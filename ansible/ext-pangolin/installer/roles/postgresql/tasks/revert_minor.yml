- name: Started patroni, if patroni stopped
  systemd:
    name: patroni
    state: restarted
    enabled: yes
    daemon_reload: yes
  become: true
  when: is_patroni_exists

- name: get PGDATA_OLD and define some variables if patroni installed
  block:

    - name: get actual PGHOME
      reciter:
        ANSIBLE_MODULE_ARGS:
          src: "{{ patroni_files.conf_dir }}/postgres.yml"
          action: get
          parameter: postgresql
          inner_parameter: bin_dir
      register: actual_pghome

    - name: define some variables
      set_fact:
        _pangolinrevert_pghome: "{{ actual_pghome.message | replace('/bin', '') }}"

  environment:
    - PYTHONPATH: "{{ python.postgresql_venv_packages }}"
  become: true
  when: is_patroni_exists

- name: Role switched to back
  block:

    - name: define current master role of the cluster
      include_role:
        name: patroni
        tasks_from: update_define_roles_of_nodes.yml

    - name: turn ON synchronous mode and then switchover
      include_role:
        name: patroni
        tasks_from: update_run_switchover
      vars:
        current_database_port: "{{ ports.pg }}"
        _runswitchover_pghome: "{{ _pangolinrevert_pghome }}"
        PGHOME: "{{ _pangolinrevert_pghome }}"
      when: ansible_fqdn != current_replica

    - name: turn ON synchronous mode and wait for cluster synchronization
      include_role:
        name: patroni
        tasks_from: update_wait_cluster_synchronization
      vars:
        current_database_port: "{{ ports.pg }}"
        PGHOME: "{{ _pangolinrevert_pghome }}"
      when: ansible_fqdn == current_replica

  when: "installation_type == 'cluster' \
         and (not (update_errors.types.pg.minor_before_first_db_started \
                  and update_errors.hosts.replica \
                  and inventory_hostname == 'replica') \
              and not (update_errors.types.pg.minor_before_bin_updated \
                  and update_errors.hosts.replica \
                  and inventory_hostname == 'replica') \
              and (update_errors.types.pg.minor_after_first_db_started \
                  and update_errors.hosts.replica \
                  and inventory_hostname == 'replica') \
              and not update_errors.types.pg.minor_before_first_switchover \
              and not (update_errors.types.pg.minor_before_first_db_started \
                      and inventory_hostname == 'master') \
              and not (update_errors.types.pg.minor_before_bin_updated \
                      and inventory_hostname == 'master') \
              and not (update_errors.types.pg.minor_after_first_db_started \
                       and inventory_hostname == 'master') \
              and not update_errors.components.checkup \
              and not update_errors.types.pg_auth_reencrypt.check_and_stop \
              and not update_errors.types.src.main \
              and not update_errors.components.rsyslog \
              and not update_errors.components.etcd \
              and not update_errors.types.patroni.main)"

# перейти в асинхронный режим, чтобы текущий мастер продолжил работать на "запись"
# чтобы patroni не выполнял failover в момент выключения одного из участников кластера
- name: Turn OFF synchronous mode and turn on PAUSE mode
  block:

    - name: turn OFF synchronous mode and turn ON PAUSE mode
      include_role:
        name: patroni
        tasks_from: update_with_patronictl.yml
      vars:
        change_params: "{{ item }}"
        PGHOME: "{{ _pangolinrevert_pghome }}"
      with_items:
        - "pause: true"
        - "synchronous_mode: false"
        - "synchronous_mode_strict: false"

  rescue:

    - debug: msg="It is ok"

  when: is_patroni_exists

- name: Recovery old Pangolin version, recovery patroni and postgresql services and configs (postgresql.conf, pg_hba.conf, postgres.yml)
  block:

    - name: recovery bash_profile
      copy:
        src:  "{{ backup_root_dir }}{{ shell_profile_file }}"
        dest: "{{ shell_profile_file }}"
        owner: postgres
        group: postgres
        mode: '0600'
        remote_src: yes
      become_user: postgres

    - name: recovery sudoers
      shell: "cp -p {{ backup_root_dir }}{{ sudoers_file }} {{ sudoers_file }}"

    - name: stop old version Pangolin
      systemd:
        name: postgresql
        state: stopped
      when: not is_patroni_exists

    - name: stop old Pangolin by pg_ctl
      shell: "{{ PGHOME_OLD }}/bin/pg_ctl stop -D {{ PGDATA_OLD }}"
      ignore_errors: yes
      become_user: postgres

    - name: stop new Pangolin by pg_ctl
      shell: "{{ PGHOME }}/bin/pg_ctl stop -D {{ PGDATA }}"
      ignore_errors: yes
      become_user: postgres

    - name: check Pangolin (must be stopped)
      shell: "ps aux"
      register: result
      until: result.stdout.find("bin/postgres") == -1
      retries: 6
      delay: 10
      become_user: postgres

    - name: check that DB doesnt work
      stat:
        path: "{{ item }}"
      register: pid_state
      failed_when: pid_state.stat.exists
      with_items:
        - "{{ PGDATA_OLD }}/postmaster.pid"
        - "{{ PGDATA }}/postmaster.pid"
      become_user: root

    - name: set python interpretator
      set_fact:
        ansible_python_interpreter: '{{ python.global_bin_2 }}'

    - name: remove installed new version Pangolin
      yum:
        name: "{{ item }}"
        state: absent
      with_items:
        - postgresql-sber-edition
        - platform-v-pangolin-dbms
      ignore_errors: yes
      become_user: root
      when: ansible_os_family == "RedHat"

    - name: remove installed new version Pangolin
      shell: "apt-get remove -y {{ item }}"
      with_items:
        - postgresql-sber-edition
        - platform-v-pangolin-dbms
      ignore_errors: yes
      become_user: root
      when: ansible_os_family == "Altlinux"

    - name: remove directory of new Pangolin version and create old
      file:
        path: "{{ item.src }}"
        state: "{{ item.state }}"
        owner: postgres
        mode: 0700
      with_items:
        - { src: "{{ PGHOME }}",     state: absent }
        - { src: "{{ PGHOME_OLD }}", state: absent }
        - { src: "{{ PGETCDIR }}",   state: absent }
        - { src: "{{ PGHOME_OLD }}", state: directory }
      become_user: root

    - name: recovery old Pangolin executable files
      block:

      - name: check PGHOME_OLD exist
        stat:
          path: "{{ PGHOME_OLD }}/bin"
        register: _pg_home_old

      - name: remove and create directory of new Pangolin version and create old
        file:
          path: "{{ item.src }}"
          state: "{{ item.state }}"
          owner: postgres
          group: postgres
          mode: 0700
        with_items:
          - { src: "{{ PGHOME_OLD }}", state: absent }
          - { src: "{{ PGHOME_OLD }}", state: directory }
        when: not _pg_home_old.stat.exists

      - name: recovery old Pangolin version
        copy:
          src: "{{ backup.postgresql }}/{{ PGHOME_OLD_NAME }}/"
          dest: "{{ PGHOME_OLD }}/"
          owner: postgres
          group: postgres
          mode: 0700
          remote_src: yes
        when: not _pg_home_old.stat.exists

      become_user: root

    - name: recovery {{ PGETCDIR }} directory
      synchronize:
        src: "{{ backup.postgresql }}/postgres"
        dest: "/etc"
      delegate_to: "{{ inventory_hostname }}"
      become_user: root
      when: ( [ pg_current_version, '4.4.0' ] | compare_pg_se_versions )|int != 0
    
    - name: recovery postgresql.conf, pg_hba.conf, postgresql.auto.conf
      copy:
        src: "{{ item.src }}"
        dest: "{{ item.dest }}"
        owner: postgres
        mode: 0600
        remote_src: yes
      with_items:
        - { dest: '{{ PGDATA_OLD }}/pg_hba.conf',          src: '{{ backup.postgresql }}{{ PGDATA_OLD }}/pg_hba.conf' }
        - { dest: '{{ PGDATA_OLD }}/postgresql.conf',      src: '{{ backup.postgresql }}{{ PGDATA_OLD }}/postgresql.conf' }
        - { dest: '{{ PGDATA_OLD }}/postgresql.auto.conf', src: '{{ backup.postgresql }}{{ PGDATA_OLD }}/postgresql.auto.conf' }
      become_user: postgres

    - name: revert old patroni configuration file
      copy:
        src: "{{ backup.patroni }}{{ patroni_files.conf_dir }}/postgres.yml"
        dest: "{{ patroni_files.conf_dir }}/postgres.yml"
        owner: postgres
        group: postgres
        mode: 0600
        remote_src: yes
      become_user: postgres
      when: is_patroni_exists

    - name: revert old configuration of patroni service
      copy:
        src: "{{ backup.patroni }}{{ patroni_files.service_file }}"
        dest: "{{ patroni_files.service_file }}"
        remote_src: yes
      when: is_patroni_exists

    - name: reload systemd and start patroni service
      systemd:
        name: patroni
        state: restarted
        daemon_reload: yes
        enabled: yes
      when: is_patroni_exists

    - name: recovery postgresql.service
      copy:
        src: "{{ backup_root_dir }}{{ service_path_dir }}/postgresql.service"
        dest: "{{ service_path_dir }}/postgresql.service"
        remote_src: yes
      become_user: root
      when: not is_patroni_exists

    - name: start old version Pangolin
      block:

        - name: start old version Pangolin by postgresql.service
          systemd:
            name: postgresql
            state: restarted
            enabled: yes
            daemon_reload: yes
          become_user: root
          when: not is_patroni_exists

        - name: start old Pangolin by pg_ctl
          shell: "{{ PGHOME_OLD }}/bin/pg_ctl start -D {{ PGDATA_OLD }}"
          ignore_errors: yes
          become_user: postgres
          when: is_patroni_exists

        - name: loop wait for pgsql started
          shell: '{{ PGHOME_OLD }}/bin/pg_isready -h 127.0.0.1 -p {{ PGPORT_OLD }}'
          register: result
          until: result.stdout.find("accepting connections") != -1
          retries: 60
          delay: 1
          become_user: postgres

  become: true
  when: is_updated_pangolin_files

- name: Turn ON synchronous mode and turn ON PAUSE mode
  include_role:
    name: patroni
    tasks_from: update_with_patronictl.yml
  vars:
    change_params: "{{ item }}"
    PGHOME: "{{ PGHOME_OLD }}"
  with_items:
    - "pause: false"
    - "synchronous_mode: true"
    - "synchronous_mode_strict: true"
  when: is_patroni_exists

- name: Reload systemd and start patroni service
  systemd:
    name: patroni
    state: restarted
    daemon_reload: yes
    enabled: yes
  become: true
  when: is_patroni_exists

- name: Reinitialize current replica
  block:

    - name: send reinit replica
      include_role:
        name: patroni
        tasks_from: update_with_patronictl
      vars:
        endpoint_name: reinit
        current_replica_for_reinit: "{{ hostvars['replica'].ansible_fqdn }}"
        PGHOME: "{{ PGHOME_OLD }}"

    - name: loop wait for pgsql started
      shell: '{{ PGHOME_OLD }}/bin/pg_isready -h 127.0.0.1 -p {{ PGPORT_OLD }}'
      register: result
      until: result.stdout.find("accepting connections") != -1
      retries: 60
      delay: 1
      become: true
      become_user: postgres

  when: "installation_type == 'cluster' \
         and (update_errors.types.pg.minor_after_first_db_started \
              or update_errors.types.pg.minor_before_second_switchover) \
         and ((inventory_hostname == 'master' \
                 and update_errors.hosts.master) \
              or (inventory_hostname == 'replica' \
                 and update_errors.hosts.replica))"

- name: Delete encrypt space of patroni db user, if pgse ver < 4.4.0
  file:
    path: "{{ pg_encrypt_cfg }}"
    state: absent
  become: true
  when: ( [ pg_current_version, '4.4.0' ] | compare_pg_se_versions )|int == 0

- name: Revert PGHOME symlinks
  block:

    - name: check {{ PGHOME_OLD }} exists
      stat:
        path: "{{ PGHOME_OLD }}"
      register: pghome_exists

    - name: check symlink /usr/pangolin exists
      stat:
        path: "/usr/pangolin"
      register: link_pghome_exists

    - name: check /usr/pgsql-se-{{ pg_major_version }} exists
      stat:
        path: "/usr/pgsql-se-{{ pg_major_version }}"
      register: other_link_pghome

    - name: recovery symlinks of PGHOME_OLD
      file:
        src: "{{ item.src }}"
        dest: "{{ item.dest }}"
        state: link
        force: yes
        owner: postgres
        group: postgres
      with_items:
        - { src: "{{ PGHOME_OLD }}",                       
            dest: "/usr/pangolin",                        
            condition: "pghome_exists.stat.exists" }
        - { src: "{{ PGHOME_OLD }}",                       
            dest: "/usr/pgsql-se-{{ pg_major_version }}", 
            condition: "pghome_exists.stat.exists" }
      when: "{{ item.condition }}"

  become: true
  when: inventory_hostname != 'etcd'