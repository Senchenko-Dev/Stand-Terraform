---

- name: Copy package to remote hosts
  copy:
    src: "{{ local_distr_path }}/{{ postgresql_package_file }}"
    dest: "{{ REMOTE_TMP }}"
  become: true

- name: Make sure previous package isn't installed
  package:
    name:  "{{ item }}"
    state: absent
  with_items:
    - postgresql-sber-edition
    - platform-v-pangolin-dbms
  become: true

- name: Install package
  package:
    name: "{{ REMOTE_TMP }}/{{ postgresql_package_file }}"
    state: present
  become: true
  when: ansible_os_family != "Altlinux"

# Because 'package:' fails with no obvious reason on ALT Linux.
- name: Install package
  command:
    cmd: "apt-get install -y '{{ REMOTE_TMP }}/{{ postgresql_package_file }}'"
  become: true
  when: ansible_os_family == "Altlinux"

- name: Copy product version file
  copy:
    src: "{{ playbook_dir }}/files/version"
    dest: "{{ PGHOME }}/share/version"
    owner: postgres
    group: postgres
    mode: u=rw,g=r,o=r
  become: true

- name: Change permissions postgresql python bin
  file:
    path: "{{ python.postgresql_venv }}/bin/"
    state: "directory"
    owner: postgres
    group: postgres
    mode: 0700
    recurse: yes
  become_user: root
  become: true

- name: Copy 3rdparty extensions
  import_tasks: copy_3rdparty_extensions.yml

- name: Copy utilities
  include_tasks: utilities.yml

- name: Copy documentation
  include_role:
    name: doc

- name: Copy timescaledb to PGHOME
  copy:
    src: "{{ item.src }}"
    dest: "{{ item.dest }}"
    owner: postgres
    group: postgres
    mode: "{{ item.mode }}"
    directory_mode: yes
  with_items:
    - { src: '{{ local_distr_path }}/timescaledb{{ PGHOME }}/lib/',             dest: '{{ PGHOME }}/lib',             mode: 600 }
    - { src: '{{ local_distr_path }}/timescaledb{{ PGHOME }}/share/extension/', dest: '{{ PGHOME }}/share/extension', mode: 600 }
  become: true

- name: Create postgresql service
  template:
    src: postgresql.service.j2
    dest: "{{ service_path_dir }}/postgresql.service"
  become: true
  when: not patroni

- name: Fill part of bash_profile for postgresql and update sudoers
  include_role:
    name: common
    tasks_from: bash_profile
  vars:
    component_name: postgresql

- name: Remove dirs if exists
  file:
    path: "{{ item }}"
    state: absent
  with_items:
    - '{{ PGDATA }}/'
    - '{{ PGLOGS }}/'
    - '{{ PGBACKUP }}'
    - '{{ PGETCDIR }}/'
  become: true

- name: Ensure data and log dirs exists
  file:
    path: "{{ item }}"
    state: directory
    owner: postgres
    group: postgres
    mode: 0700
    recurse: yes
  with_items:
    - '{{ PGUSERHOME }}/'
    - "/{{ PGDATA.replace('/', ' ').split().0 }}"
    - "/{{ PGLOGS.replace('/', ' ').split().0 }}"
    - '{{ PGDATA }}/'
    - '{{ PGLOGS }}/'
    - '{{ PGBACKUP }}'
    - '/var/run/postgresql/'
    - '{{ PGETCDIR }}/'
  become: true

- name: Change owner for sos file
  file:
    path: "/{{ PGDATA.replace('/', ' ').split().0 }}/sos"
    owner: postgres
    group: postgres
    mode: 0600
  become: true
  when: "stand == 'prom' and (inventory_hostname == 'master' or inventory_hostname == 'replica')"

- name: Ensure tablespace_location dir exists
  file:
    path: "{{ tablespace_location }}/{{ tablespace_name }}"
    state: 'directory'
    owner: postgres
    group: postgres
    mode: 0700
  become: true
  when: "tablespace_name|length > 0"

- name: Initializate database and copy templates for configs
  block:

    - name: initializate standalone database
      shell: "{{ PGHOME }}/bin/pg_ctl -D {{ PGDATA }} initdb -o --data-checksums"
      environment:
        PG_PLUGINS_PATH: "{{ PGHOME }}/lib"

    - name: initialize protection
      shell:
        cmd: "{{ PGHOME }}/bin/initprotection -D {{ PGDATA }}\ 
             -U {{ admin_protection_users.sec_admin_backup.user_name }},{{ admin_protection_users.sec_admin.user_name }}\ 
             -P '{{ admin_protection_users.sec_admin_backup.password }}','{{ admin_protection_users.sec_admin.password }}'"
      environment:
        PG_PLUGINS_PATH: "{{ PGHOME }}/lib"
      when: "admin_protection is defined and admin_protection"

    - name: rename default configs to base.conf
      shell: |
        mv "{{ PGDATA }}/postgresql.conf" "{{ PGDATA }}/postgresql.base.conf"
        mv "{{ PGDATA }}/pg_hba.conf" "{{ PGDATA }}/pg_hba.base.conf"

    - name: configure standalone postgresql.conf
      template:
        src: postgresql.conf.j2
        dest: "{{ PGDATA }}/postgresql.conf"
        owner: postgres
        group: postgres
        mode: 0600
        trim_blocks: False

    - name: Configure pg_hba.conf
      template:
        src: pg_hba.conf.j2
        dest: "{{ PGDATA }}/pg_hba.conf"
        owner: postgres
        group: postgres
        mode: 0600

  become_user: postgres
  become: true
  when: master is defined and "'postgresql-sber-edition' not in ansible_facts.packages"

- name: Setup delete and compress old logs
  template:
    src: postgresql_clean_logs.j2
    dest: "{{ global_scripts }}/postgresql_clean_logs"
    owner: postgres
    group: postgres
    mode: 0751
  become: true

- name: Creates cron job
  cron:
    name: "a job for postgresql clean logs"
    special_time: daily
    job: "{{ global_scripts }}/postgresql_clean_logs"
  become: true
  become_user: postgres

- name: Generate certificates
  include_role:
    name: postgresql
    tasks_from: generate_certs.yml
  when: not ssl_mode

- name: initialize kms configuration
  block:

    - name: execute shell command for initializing KMS config
      shell: |
        set timeout -1
        spawn {{ PGHOME }}/bin/setup_kms_credentials
        match_max 100000
        expect "Choose credentials domain:"
        send -- "1\r"
        expect "Enter Pangolin cluster ID:"
        send -- "{{ KMS_CLUSTER_ID }}\r"
        expect "Enter IP address:"
        send -- "{{ KMS_HOST }}\r"
        expect "Enter port:"
        send -- "{{ KMS_PORT }}\r"
        expect "Choose credentials type:"
        send -- "1\r"
        expect "Enter login:"
        send -- "{{ KMS_LOGIN }}\r"
        expect "Enter password:"
        send -- "{{ KMS_PASSWORD }}\r"
        expect "Confirm password:"
        send -- "{{ KMS_PASSWORD }}\r"
        expect "Do you want to add another KMS credentials? (yes/no)?:"
        send -- "no\r"
        expect eof
      args:
        executable: "expect"
      environment:
        PG_PLUGINS_PATH: "{{ PGHOME }}/lib"
      become_user: postgres
      register: kms_initialize_command

    - name: check created kms config
      stat:
        path: "{{ KMS_CONFIG }}"
      register: kms_config_file

    - name: check that config created
      assert:
        that: kms_config_file.stat.exists
        fail_msg: "KMS config doesn't exists. May be result of setup_kms_credentials command has errors"

    - name: check that kms config created without errors
      assert:
        that: not "Error" in kms_initialize_command.stdout
        fail_msg: "KMS configuration created with errors"

  become: true
  when: "(tde is defined and tde) or (admin_protection is defined and admin_protection)"

- name: Start database and check process of postgresql
  block:

    - name: start db daemon
      shell: "{{ PGHOME }}/bin/postgres -D {{ PGDATA }} &"
      environment:
        PG_PLUGINS_PATH: "{{ PGHOME }}/lib"
      become_user: postgres
      when: patroni

    - name: start db daemon
      systemd:
        name: postgresql
        state: started
        daemon_reload: yes
        enabled: yes
      when: not patroni

    - name: loop wait for pgsql started
      shell: '{{ PGHOME }}/bin/pg_isready -h 127.0.0.1 -p {{ ports.pg }}'
      register: result
      until: result.stdout.find("accepting connections") != -1
      retries: 60
      delay: 1
      become_user: postgres

  become: true
  when: master is defined and "'postgresql-sber-edition' not in ansible_facts.packages"

- name: Gather packages info
  package_facts:
    manager: "auto"
  no_log: "{{ nolog }}"

- name: Remember current PG SE version
  set_fact:
    pg_current_version: "{{ ansible_facts.packages['postgresql-sber-edition'][0].version }}"
  when: "'postgresql-sber-edition' in ansible_facts.packages"

- name: Add and configure patroni db user
  block:

    - name: add and configure patroni db user
      include_role:
        name: postgresql
        tasks_from: add_and_configure_db_user_with_enc_space.yml
      vars:
        _addcfgdbuserenc_pghome: "{{ PGHOME }}"
        _addcfgdbuserenc_user: patroni
        _addcfgdbuserenc_dbnames: ["postgres", "replication"]
        _addcfgdbuserenc_privs: 'LOGIN SUPERUSER REPLICATION NOINHERIT'
        _addcfgdbuserenc_input_user_pass: '{% if patroni_user_pass is defined and patroni_user_pass|length > 0 %}{{ patroni_user_pass }}{% endif %}'

    - name: save patroni user pass
      set_fact:
        patroni_user_pass: "{{ _addcfgdbuserenc_output_user_pass }}"

  no_log: "{{ nolog }}"
  when: patroni and action_type == 'install'

- name: Set permission files protect
  import_tasks: set_permission_files_protect.yml