- name: Set python interpretator
  set_fact:
    ansible_python_interpreter: '{{ python.global_bin_2 }}'

- name: Get service_facts
  service_facts:
  no_log: "{{ nolog }}"
  become: true

- name: Remove simlink PGDATA and PGHOME if exists
  block:

      - name: find link to PGDATA
        stat:
          path: "/pgdata/data"
        register: li_pgdata

      - name: find link to PGHOME
        stat:
          path: "/usr/pangolin"
        register: li_pghome

      - name: find link to PGHOME other
        stat:
          path: "/usr/pgsql-se-{{ pg_major_version }}"
        register: other_li_pghome_new

      - name: find link to PGDATA_new
        stat:
          path: "/pgdata/{{ pg_major_version }}"
        register: li_pgdata_new

      - name: find link to PGBACKUP
        stat:
          path: "/pgarclogs/{{ pg_major_version }}"
        register: li_pgbackup

      - name: remove link to PGDATA
        file:
          path: "/pgdata/data"
          state: absent
        when: "li_pgdata.stat.exists and li_pgdata.stat.islnk"

      - name: remove link to PGHOME
        file:
          path: "/usr/pangolin"
          state: absent
        when: "li_pghome.stat.exists and li_pghome.stat.islnk"

      - name: remove link to PGHOME
        file:
          path: "/usr/pgsql-se-{{ pg_major_version }}"
          state: absent
        when: "other_li_pghome_new.stat.exists and other_li_pghome_new.stat.islnk"

      - name: remove link to PGDATA
        file:
          path: "/pgdata/{{ pg_major_version }}"
          state: absent
        when: "li_pgdata_new.stat.exists and li_pgdata_new.stat.islnk"

      - name: remove link to PGBACKUP
        file:
          path: "/pgarclogs/{{ pg_major_version }}"
          state: absent
        when: "li_pgbackup.stat.exists and li_pgbackup.stat.islnk"

  become: true
  when: inventory_hostname != 'etcd'

- name: Recovery old Pangolin version, recovery patroni and postgresql services and configs (postgresql.conf, pg_hba.conf, postgres.yml)
  block:

    - name: recovery bash_profile
      copy:
        src:  "{{ backup_root_dir }}{{ shell_profile_file }}"
        dest: "{{ shell_profile_file }}"
        owner: postgres
        group: postgres
        mode: '0600'
        remote_src: yes
      become_user: postgres

    - name: recovery sudoers
      shell: "cp -p {{ backup_root_dir }}{{ sudoers_file }} {{ sudoers_file }}"

    - name: stopped patroni and Pangolin
      systemd:
        name: patroni
        state: stopped
      when: is_patroni_exists

    - name: stop old version PG SE
      systemd:
        name: postgresql
        state: stopped
      when: not is_patroni_exists

    - name: stop old Pangolin by pg_ctl
      shell: "{{ PGHOME_OLD }}/bin/pg_ctl stop -D {{ PGDATA_OLD }}"
      ignore_errors: yes
      become_user: postgres

    - name: stop new Pangolin by pg_ctl
      shell: "{{ PGHOME }}/bin/pg_ctl stop -D {{ PGDATA }}"
      ignore_errors: yes
      become_user: postgres

    - name: check Pangolin (must be stopped)
      shell: "ps aux"
      register: result
      until: result.stdout.find("bin/postgres") == -1
      retries: 6
      delay: 10
      become_user: postgres

    - name: check that DB doesnt work
      stat:
        path: "{{ item }}"
      register: pid_state
      failed_when: pid_state.stat.exists
      with_items:
        - "{{ PGDATA_OLD }}/postmaster.pid"
        - "{{ PGDATA }}/postmaster.pid"
      become_user: root

    - name: set python interpretator
      set_fact:
        ansible_python_interpreter: '{{ python.global_bin_2 }}'

    - name: remove installed new version Pangolin
      yum:
        name: "{{ item }}"
        state: absent
      with_items:
        - postgresql-sber-edition
        - platform-v-pangolin-dbms
      ignore_errors: yes
      become_user: root
      when: ansible_os_family == "RedHat"

    - name: remove installed new version Pangolin
      shell: "apt-get remove -y {{ item }}"
      with_items:
        - postgresql-sber-edition
        - platform-v-pangolin-dbms
      ignore_errors: yes
      become_user: root
      when: ansible_os_family == "Altlinux"

    - name: remove directory of new Pangolin version
      file:
        path: "{{ item }}"
        state: absent
      with_items:
        - "{{ PGHOME }}"
        - "{{ PGETCDIR }}"
        - "{{ pgdata_new_string.stdout }}"
        - "{{ PGBACKUP }}"
      become_user: root

    - name: create directory of {{ PGDATA_OLD }} if not exists
      file:
        path: "{{ PGDATA_OLD }}"
        state: directory
        owner: postgres
        group: postgres
        mode: 0700
      become_user: root

    - name: check structure old version and drop tablespace new version
      block:

        - name: get structure tablespace old version
          find:
            paths: "{{ tablespace_old_path }}"
            recurse: yes
            file_type: directory
            depth: 2
          register: tablespace_structure

        - name: remove new tablespace
          file:
            path: "{{ item }}"
            state: absent
          with_items:
            - "{{ tablespace_structure.files | map(attribute='path') | list | difference(tablespace_structure_old) }}"

      become_user: root
      when: tablespace_structure_old is defined and tablespace_structure_old

    - name: recovery old pg se version
      block:

      - name: check PGHOME_OLD exist
        stat:
          path: "{{ PGHOME_OLD }}/bin"
        register: _pg_home_old

      - name: remove and create directory of new Pangolin version and create old
        file:
          path: "{{ item.src }}"
          state: "{{ item.state }}"
          owner: postgres
          group: postgres
          mode: 0700
        with_items:
          - { src: "{{ PGHOME_OLD }}", state: absent }
          - { src: "{{ PGHOME_OLD }}", state: directory }
        when: not _pg_home_old.stat.exists

      - name: recovery old pg se version
        copy:
          src: "{{ backup.postgresql }}/{{ PGHOME_OLD_NAME }}/"
          dest: "{{ PGHOME_OLD }}/"
          owner: postgres
          group: postgres
          mode: 0700
          remote_src: yes
        when: not _pg_home_old.stat.exists

      become_user: root

    - name: —Åhange permissions /pgdata
      file:
        path: "/pgdata"
        state: directory
        owner: postgres
        group: postgres
        mode: 0700
        recurse: yes
      become_user: root

    - name: recovery {{ PGETCDIR }} directory
      synchronize:
        src: "{{ backup.postgresql }}/postgres"
        dest: "/etc"
      delegate_to: "{{ inventory_hostname }}"
      become_user: root
      when: ( [ pg_current_version, '4.4.0' ] | compare_pg_se_versions )|int != 0

    - name: recovery postgresql.conf, pg_hba.conf, postgresql.auto.conf
      copy:
        src: "{{ item.src }}"
        dest: "{{ item.dest }}"
        owner: postgres
        mode: 0600
        remote_src: yes
      with_items:
        - { dest: '{{ PGDATA_OLD }}/pg_hba.conf',          src: '{{ backup.postgresql }}{{ PGDATA_OLD }}/pg_hba.conf' }
        - { dest: '{{ PGDATA_OLD }}/postgresql.conf',      src: '{{ backup.postgresql }}{{ PGDATA_OLD }}/postgresql.conf' }
        - { dest: '{{ PGDATA_OLD }}/postgresql.auto.conf', src: '{{ backup.postgresql }}{{ PGDATA_OLD }}/postgresql.auto.conf' }
      become_user: postgres

    - name: rename pg_control.old
      block:

      - name: check pg_control.old exist
        stat:
          path: "{{ PGDATA_OLD }}/global/pg_control.old"
        register: _pg_control_old

      - name: rename pg_control.old
        copy:
          dest: "{{ PGDATA_OLD }}/global/pg_control"
          src: "{{ PGDATA_OLD }}/global/pg_control.old"
          owner: postgres
          group: postgres
          mode: 0600
          remote_src: yes
        when: _pg_control_old.stat.exists

      when: "inventory_hostname == 'master' \
             and update_errors.types.pg.major_main_migrate_master_db"

    - name: recovery database if major update and new DB started
      block:

        - name: find partial WAL files
          find:
            paths: "{{ backup.pg_probackup_bak_dir }}/pg_probackup/wal/{{ clustername }}"
            patterns: '*.partial'
          register: partial_wals

        - name: rename partial WAL
          shell: "mv {{ item.path }} {{ item.path.replace('.partial', '') }}"
          loop: "{{ partial_wals.files }}"

        - name: remove {{ PGDATA_OLD }}
          file:
            path: "{{ item.src }}"
            state: "{{ item.state }}"
            owner: postgres
            group: postgres
            mode: 0700
          with_items:
            - { src: "{{ (PGDATA_OLD | regex_replace('/$', '')).split('/')[0:-1] | join ('/') }}", state: absent }
            - { src: "{{ (PGDATA_OLD | regex_replace('/$', '')).split('/')[0:-1] | join ('/') }}", state: directory }
          become_user: root

        - name: restore old link if exist
          file:
            src: "{{ pgdata_link.stat.lnk_source }}"
            dest: "{{ pgdata_link.stat.path }}"
            state: link
            force: yes
            owner: postgres
            group: postgres
          when: "{{ pgdata_link.stat.islnk }}"

        - name: restore database with pg_probackup
          pangolin_pg_probackup:
            ANSIBLE_MODULE_ARGS:
              method: restore
              path_backup: "{{ backup.pg_probackup_bak_dir }}/pg_probackup"
              instance: "{{ clustername }}"
              thread_worker: "{{ proc_cpu_for_ansible_used }}"
              any_opts:
                - "--progress"
                - "--restore-command=cp {{ backup.pg_probackup_bak_dir }}/pg_probackup/wal/{{ clustername }}/%f  %p"
          async: 1000000
          poll: 0
          register: restore_progress
          ignore_errors: yes
          become_flags: "-i"

        - debug: msg="{{ update_control_msgs.info.pg_probackup_restore_start }}"

        - name: show restore progress pg_probackup
          async_status:
            jid: "{{ restore_progress.ansible_job_id }}"
          register: job_result
          until: job_result.finished
          retries: 3000
          delay: 60

        - name: make sure that restore done
          assert:
            that: not restore_progress.failed
            success_msg: "{{ update_control_msgs.info.pg_probackup_restore_ok }}"
            fail_msg: "{{ update_control_msgs.fails.pg_probackup_restore_failed }}"

      become_user: postgres
      when: "inventory_hostname == 'master' \
            and (update_errors.types.pg.major_main_migrate_replica_db \
                 or update_errors.types.pg.major_main_start_after_migrate_db \
                 or update_errors.types.pg.major_post \
                 or update_errors.types.patroni.finally \
                 or update_errors.components.configuration \
                 or update_errors.types.src.install_pg_probackup \
                 or update_errors.components.pgbouncer \
                 or update_errors.components.haproxy \
                 or update_errors.types.pg_auth_reencrypt.finally \
                 or update_errors.components.finally \
                 or update_errors.components.tests)"

    - name: recovery postgresql.service
      copy:
        src: "{{ backup_root_dir }}{{ service_path_dir }}/postgresql.service"
        dest: "{{ service_path_dir }}/postgresql.service"
        remote_src: yes
      become_user: root
      when: not is_patroni_exists

    - name: start old version Pangolin
      block:

        - name: start old version Pangolin by postgresql.service
          systemd:
            name: postgresql
            state: started
            enabled: yes
            daemon_reload: yes
          become_user: root
          when: not is_patroni_exists

        - name: start old Pangolin by pg_ctl
          shell: "{{ PGHOME_OLD }}/bin/pg_ctl start -D {{ PGDATA_OLD }}"
          become_user: postgres
          when: is_patroni_exists

        - name: loop wait for pgsql started
          shell: '{{ PGHOME_OLD }}/bin/pg_isready -h 127.0.0.1 -p {{ PGPORT_OLD }}'
          register: result
          until: result.stdout.find("accepting connections") != -1
          retries: 60
          delay: 1
          become_user: postgres

      when: "inventory_hostname == 'master' \
             or not (update_errors.types.configuration.finally \
                     or update_errors.types.pg_auth_reencrypt.finally \
                     or update_errors.components.finally \
                     or update_errors.types.src.install_pg_probackup \
                     or update_errors.components.tests \
                     or update_errors.hosts.replica \
                        and (update_errors.types.pg.major_post \
                              or update_errors.types.patroni.finally \
                              or update_errors.components.pgbouncer \
                              or update_errors.components.haproxy ))"

  become: true