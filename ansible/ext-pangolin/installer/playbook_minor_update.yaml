- name: Get ping response and gather packages info
  hosts: localhost:all
  tasks:
    - set_fact: update_time_started="{{ lookup('pipe','date \"+%Y-%m-%d %H:%M:%S\"') }}"
    - action: ping
    - set_fact:
        the_ansible_local_address: "{{ hostvars['127.0.0.1'].ansible_default_ipv4.address }}"
      run_once: true
    - package_facts:
        manager: "auto"
      no_log: "{{ nolog }}"
  tags: standalone,cluster

########################################   standalone-postgresql-only          ########################################
########################################   standalone-postgresql-pgbouncer     ########################################
########################################   standalone-patroni-etcd-pgbouncer   ########################################
- hosts: master
  roles:
    - { role: checkup }
    - { role: pg_auth_reencrypt,    when: auth_reencrypt and not update_errors.aggregate, operation_type: check_and_stop }
    - { role: rsyslog,              when: not update_errors.aggregate }
    - { role: SRC,                  when: SRC is defined and SRC and not update_errors.aggregate, operation_type: update_pg_server }
    - { role: etcd,                 when: etcd and not update_errors.aggregate,  vars: { post_update: false } }
    - { role: etcd,                 when: etcd and not update_errors.aggregate,  vars: { post_update: true } }
    - { role: patroni,              when: patroni and not update_errors.aggregate,  vars: { post_update: false } }
    - { role: postgresql,           when: postgres and not update_errors.aggregate }
    - { role: patroni,              when: patroni and not update_errors.aggregate,  vars: { post_update: true } }
    - { role: pgbouncer,            when: pgbouncer and not update_errors.aggregate }
    - { role: configure,            when: not update_errors.aggregate, operation_type: main_configure }
    - { role: finally,              when: not update_errors.aggregate, operation_type: switch_to_original_configs }
    - { role: tests,                when: not update_errors.aggregate and run_smoke_test, vars: { cluster: false }}
    - { role: configure,            when: not update_errors.aggregate, operation_type: finish_configure }
    - { role: finally,              when: not update_errors.aggregate, operation_type: change_linux_password }
    - { role: finally,              when: not update_errors.aggregate, operation_type: finish_update, vars: { _fnshupdt_pghome: "{{ PGHOME }}",
                                                                                                              _fnshupdt_pgdata: "{{ PGDATA }}" } }
    - { role: pg_auth_reencrypt,    when: auth_reencrypt and not update_errors.aggregate, operation_type: install_and_update, vars: { _reencrypt_pgdata: "{{ PGDATA }}" } }
  tags: standalone

########################################   cluster-patroni-etcd-pgbouncer           ########################################
########################################   cluster-patroni-etcd-pgbouncer-haproxy   ########################################
- hosts: master:replica:etcd
  roles:
    - { role: checkup,              when: not update_errors.aggregate }
    - { role: pg_auth_reencrypt,    when: auth_reencrypt and not update_errors.aggregate, operation_type: check_and_stop }
    - { role: rsyslog,              when: not update_errors.aggregate }
    - { role: SRC,                  when: SRC is defined and SRC and not update_errors.aggregate, operation_type: update_pg_server }
    - { role: etcd,                 when: etcd and not update_errors.aggregate,  vars: { post_update: false } }
    - { role: etcd,                 when: etcd and not update_errors.aggregate,  vars: { post_update: true } }
  tags: cluster
- hosts: master:replica:etcd
  tasks:
    - { include_role: { name: common, tasks_from: update_errors_sync_to_hosts.yml } }
  tags: cluster
- hosts: master
  roles:
    - { role: patroni,    when: patroni and not update_errors.aggregate,  vars: { post_update: false } }
  tags: cluster
- hosts: master:replica:etcd
  tasks:
    - { include_role: { name: common, tasks_from: update_errors_sync_to_hosts.yml } }
  tags: cluster
- hosts: replica
  roles:
    - { role: patroni,    when: patroni and not update_errors.aggregate,  vars: { post_update: false } }
  tags: cluster
- hosts: master:replica:etcd
  tasks:
    - { include_role: { name: common, tasks_from: update_errors_sync_to_hosts.yml } }
  tags: cluster
- hosts: replica
  roles:
    - { role: postgresql, when: postgres and not update_errors.aggregate }
    - { role: patroni,    when: patroni and not update_errors.aggregate,  vars: { post_update: true } }
    - { role: pgbouncer,  when: pgbouncer and not update_errors.aggregate }
    - { role: HAProxy,    when: haproxy and not update_errors.aggregate }
  tags: cluster
- hosts: master:replica:etcd
  tasks:
    - { include_role: { name: common, tasks_from: update_errors_sync_to_hosts.yml } }
  tags: cluster
- hosts: master
  roles:
    - { role: postgresql, when: postgres and not update_errors.aggregate }
    - { role: patroni,    when: patroni and not update_errors.aggregate,  vars: { post_update: true } }
    - { role: pgbouncer,  when: pgbouncer and not update_errors.aggregate }
    - { role: HAProxy,    when: haproxy and not update_errors.aggregate }
  tags: cluster
- hosts: master:replica:etcd
  tasks:
    - { include_role: { name: common, tasks_from: update_errors_sync_to_hosts.yml } }
  tags: cluster
- hosts: master:replica:etcd
  roles:
    - { role: configure,  when: not update_errors.aggregate, operation_type: main_configure }
    - { role: finally,    when: not update_errors.aggregate, operation_type: switch_to_original_configs }
    - { role: tests,      when: not update_errors.aggregate and run_smoke_test , vars: { cluster: true }}
    #- { role: finally,    when: not update_errors.aggregate, operation_type: turn_off_etcd_v2 }
  tags: cluster
- hosts: master:replica:etcd
  tasks:
    - { include_role: { name: common, tasks_from: update_errors_sync_to_hosts.yml } }
  tags: cluster
- hosts: master:replica
  roles:
    - { role: configure,            when: not update_errors.aggregate, operation_type: finish_configure }
    - { role: finally,              when: not update_errors.aggregate, operation_type: finish_update, vars: { _fnshupdt_pghome: "{{ PGHOME }}",
                                                                                                              _fnshupdt_pgdata: "{{ PGDATA }}" } }
    - { role: pg_auth_reencrypt,    when: auth_reencrypt and not update_errors.aggregate, operation_type: install_and_update, vars: { _reencrypt_pgdata: "{{ PGDATA }}" } }
  tags: cluster
- hosts: master:replica:etcd
  tasks:
    - { include_role: { name: common, tasks_from: update_errors_sync_to_hosts.yml } }
  tags: cluster
- hosts: master:replica:etcd
  roles:
    - { role: finally, when: not update_errors.aggregate, operation_type: change_linux_password }
  tags: cluster
- hosts: master:replica:etcd
  tasks:
    - { include_role: { name: common, tasks_from: update_errors_sync_to_hosts.yml } }
  tags: cluster

########################################   recovery if error   ########################################
- hosts: master:replica:etcd
  roles:
    - { role: recovery, when: handle_update_errors and update_errors.aggregate, recovery_type: checkup }
    - { role: recovery, when: handle_update_errors and update_errors.aggregate, recovery_type: etcd }
    - { role: recovery, when: handle_update_errors and update_errors.aggregate, recovery_type: rsyslog }
    - { role: recovery, when: handle_update_errors and update_errors.aggregate, recovery_type: revert_pg_server }
  tags: standalone,cluster

- hosts: master:replica
  serial: 1
  roles:
    - { role: recovery, when: handle_update_errors and update_errors.aggregate, recovery_type: patroni }
  tags: standalone,cluster

- hosts: master
  roles: 
    - { role: recovery, when: handle_update_errors and update_errors.aggregate, recovery_type: postgresql }
    - { role: recovery, when: handle_update_errors and update_errors.aggregate, recovery_type: pgbouncer }
    - { role: recovery, when: handle_update_errors and update_errors.aggregate, recovery_type: haproxy }
  tags: standalone,cluster

- hosts: replica
  roles:
    - { role: recovery, when: handle_update_errors and update_errors.aggregate, recovery_type: postgresql }
    - { role: recovery, when: handle_update_errors and update_errors.aggregate, recovery_type: pgbouncer }
    - { role: recovery, when: handle_update_errors and update_errors.aggregate, recovery_type: haproxy }
  tags: cluster

- hosts: replica:master
  serial: 1
  roles:
    - { role: recovery, when: handle_update_errors and update_errors.aggregate, recovery_type: finally }
    - { role: recovery, when: handle_update_errors and update_errors.aggregate, recovery_type: pg_auth_reencrypt }
  tags: standalone,cluster

######################################## finish playbook and print finished ########################################

- name: Unblock traffic
  hosts: master:replica:etcd
  tasks:

    - name: unblock traffic
      include_role:
        name: common
        tasks_from: block_traffic
      vars:
        block_traffic: false
        the_current_haproxy_port: "{{ ports.haproxy }}"
        the_current_pgbouncer_port: "{{ ports.pgbouncer }}"
        the_current_pg_port: "{{ ports.pg }}"

  tags: standalone,cluster

- name: Return original SRC scripts
  hosts: master:replica
  roles:
    - { role: SRC,      when: SRC is defined and SRC, operation_type: return_original_scripts }
  tags: standalone,cluster

- name: Finish playbook and print finished messages
  hosts: master
  tasks:

    - name: clear cache update directory
      file:
        path: "{{ update_status_files.dir }}"
        state: absent
      become: true
      when: not update_errors.aggregate

    - name: delete disallow file
      file:
        path: "{{ update_status_files.disallow_update }}"
        state: absent
      become: true
      when: handle_update_errors

    - name: write to process status work
      include_role:
        name: common
        tasks_from: add_process_status_logs
      vars:
        process_work_status: "{% if update_errors.aggregate and not handle_update_errors %}\
                                  {{ process_work_statuses.all_updates.error }}\
                              {% elif update_errors.aggregate and not is_recovery_available %}\
                                  {{ process_work_statuses.recovery.unavailable }}\
                              {% elif update_errors.aggregate and is_recovery_available %}\
                                  {{ process_work_statuses.recovery.finish }}\
                              {% else %}\
                                  {{ process_work_statuses.all_updates.finish }}\
                              {% endif %}"
        recovery_key: "{% if handle_update_errors and update_errors.aggregate %}\
                          True\
                       {% else %}\
                          False\
                       {% endif %}"
      when: not update_errors.components.checkup

    - debug: msg="{{ update_errors }}"

    - set_fact: update_time_finished="{{ lookup('pipe','date \"+%Y-%m-%d %H:%M:%S\"') }}"
    - set_fact: full_update_time="{{ ((update_time_finished | to_datetime) - (update_time_started | to_datetime)).total_seconds() / 60 | int  }}"
    - debug: msg="{{ update_control_msgs.info.full_update_time | replace('full_update_time',full_update_time) }}"
      when: not update_errors.components.checkup

    - debug: msg="{{ control_name }}.FAIL__В процессе сбора необходимой для старта обновления СУБД информации произошла ошибка. 
             Обратитесь к Администраторам СУБД. СУБД находится в исходном состоянии, восстановление не требуется.__{{ control_name }}.FAIL"
      when: update_errors.components.checkup
      
    - debug: msg="{% if update_errors.components.configuration %}\
                        {{ update_control_msgs.fails.update_component_config_fail }}\
                  {% elif update_errors.components.pg %}\
                        {{ update_control_msgs.fails.update_component_pg_fail }}\
                  {% elif update_errors.components.patroni %}\
                        {{ update_control_msgs.fails.update_component_patroni_fail }}\
                  {% elif update_errors.components.pgbouncer %}\
                        {{ update_control_msgs.fails.update_component_pgbouncer_fail }}\
                  {% elif update_errors.components.haproxy %}\
                        {{ update_control_msgs.fails.update_component_haproxy_fail }}\
                  {% elif update_errors.components.checkup %}\
                        {{ update_control_msgs.fails.update_component_checkup_fail }}\
                  {% elif update_errors.components.rsyslog %}\
                        {{ update_control_msgs.fails.update_component_rsyslog_fail }}\
                  {% elif update_errors.components.pg_auth_reencrypt %}
                        {{ update_control_msgs.fails.update_component_pg_auth_reencrypt_fail }}\
                  {% endif %}"
      when: update_errors.aggregate and not update_errors.components.checkup

    - debug: msg="{% if not update_errors.aggregate %}
                      {{ update_control_msgs.ok.update_successfully }}
                  {% else %}
                      {{ update_control_msgs.fails.update_failed }}
                  {% endif %}"
      when: not update_errors.components.checkup

  tags: standalone,cluster
