# Руководство прикладного разработчика

Platform V Pangolin - система управления базами данных, основанная на PostgreSQL. В этом документе приведена информация, необходимая для разработки приложений, подключаемых к Pangolin.

Этот документ предназначен разработчиков приложений, подключаемых к СУБД Pangolin.

## Системные требования

Platform V Pangolin развертывается на базе ОС Linux Red Hat 7.8.

Для установки Platform V Pangolin на сервер на базе Linux потребуются:

-   Ansible не ниже версии 2.9.2
-   sshpass
-   Модули Python:
    -   jmespath версии 0.9.4 
    -   netaddr версии 0.7.19 
    -   PyYAML версии 5.3

Функциональные требования к оборудованию перечислены в таблице ниже.

| <br>№ | <br>Назначение сервера                                   | <br>Количество |             |                                  |                        |                              |
| ----- | -------------------------------------------------------- | -------------- | ----------- | -------------------------------- | ---------------------- | ---------------------------- |
|       |                                                          | <br>CPU (core) | <br>RAM, Gb | <br>Локальные диски, Gb          | <br>Сетевые интерфейсы | <br>Интерфейсы сети хранения |
| <br>1 | <br>Сервер   баз данных                                  | <br>4          | <br>24      | <br>OS:   2SSD<br>   <br>150+150 | <br>4                  | <br>2                        |
| <br>2 | <br>Сервер   обработки событий аудита <br>   (syslog-ng) | <br>4          | <br>24      | <br>OS:   2SSD<br>   <br>150+150 | <br>4                  | <br>2                        |

## Подключение и конфигурирование

В рамках данного руководства среда будет подготовлена к разработке приложения на языке C++, с использованием компилятора `gcc` и интерфейсной библиотеки `libpqxx`. Эти язык, компилятор и библиотека выбраны в качестве примера; разработчик может использовать любые доступные ему комбинации инструментов.

### Установка и настройка Pangolin

Установите СУБД Pangolin и подготовьте её к работе. Процедура установки Pangolin подробно описана в документе *Руководство по установке*.

### Установка gcc
<!--В поставке есть?-->
gcc - это компилятор языка C, который потребуется для сборки компонентов среды разработки и для компиляции непосредственно программ на языке C.

Чтобы установить gcc, выполните в терминале:

```Bash
sudo apt-get install gcc
```

### Установка libpq-dev
<!--В доках, на основании которых я писал гайд, ничего про него не было, но у меня без него не собирался libpqxx-->
Пакет `libpq-dev` содержит заголовочные файлы и статическую библиотеку для компиляции программ на C с использованием библиотеки `libpq`, которая отвечает за взаимодействие с серверной частью Pangolin.

```Bash
sudo apt-get install libpq-dev
```

### Установка libpqxx

В этом руководстве для разработки первого приложения будет использоваться open-source библиотека `libpqxx` - официальный C++ API для PostgreSQL, полностью совместимый с Pangolin.

Загрузите и установите актуальную версию `libpqxx`. Для этого выполните в терминале:

```Bash
wget http://pqxx.org/download/software/libpqxx/libpqxx-4.0.tar.gz
tar xvfz libpqxx-4.0.tar.gz
cd libpqxx-4.0
./configure
make
make install
```

Теперь откройте файл `pg_hba.conf` в директории Pangolin и добавьте в него следующую строку:

```Text
## IPv4 local connections:
host    all         all         127.0.0.1/32          md5
```

Затем перезапустите Pangolin:

```Bash
[root@host]# service postgresql restart
Stopping postgresql service:                               [  OK  ]
Starting postgresql service:                               [  OK  ]
```

## Разработка первого приложения с использованием программного продукта

В этом разделе описывается разработка приложений, взаимодействующих с СУБД Pangolin.

### Создание тестовой базы данных

Создайте тестовую базу данных, с которой будет работать приложение.
Чтобы создать тестовую базу данных `testdb`, запустите интерфейс командной строки Pangolin (`psql`) и выполните команду:

```SQL
CREATE DATABASE testdb;
```

> Внимание!<br>Для выполнения определенных команд вам могут потребоваться права на подключение к БД и набор прав для работы с данными (DDL, DML). Убедитесь, что у вашей учетной записи есть необходимые права доступа, или войдите в систему под учетной записью, которой такие права предоставлены (например, `postgres`).<br>Подробнее о правах доступа и ролевой модели Pangolin рассказывается в документах *Детальная архитектура* и *Руководство администратора*.

Убедитесь, что новая база данных создана. Для этого в интерфейсе командной строки Pangolin выполните команду `\l`. Вы увидите примерно следующее:

```SQL
postgres-# \l
                             List of databases
   Name    |  Owner   | Encoding | Collate | Ctype |   Access privileges   
-----------+----------+----------+---------+-------+-----------------------
 postgres  | postgres | UTF8     | C       | C     | 
 template0 | postgres | UTF8     | C       | C     | =c/postgres          +
           |          |          |         |       | postgres=CTc/postgres
 template1 | postgres | UTF8     | C       | C     | =c/postgres          +
           |          |          |         |       | postgres=CTc/postgres
 testdb    | postgres | UTF8     | C       | C     | 
(4 rows)
postgres-# 
```

### Подключение к базе данных

Приведенный ниже код реализует подключение к базе данных на локальной машине через порт 5433 от имени пользователя `postgres`.
<!--Здесь и далее код тестировался на ванильной PostgreSQL 9.3 под Ubuntu 14.04 -->
```C++
#include <iostream>
#include <pqxx/pqxx> 

using namespace std;
using namespace pqxx;

int main(int argc, char* argv[]) {
   try {
      connection C("dbname = testdb user = postgres password = <пароль> \
      hostaddr = 127.0.0.1 port = 5433");
      if (C.is_open()) {
        cout << "Подключение к базе данных " << C.dbname() << " установлено." << endl;
      } else {
        cout << "Не удаётся установить подключение к базе данных." << endl;
        return 1;
      }
      C.disconnect ();
   } catch (const std::exception &e) {
      cerr << e.what() << std::endl;
      return 1;
   }
}
```

Скомпилируйте программу и выполните её:

```Bash
$ gсс test.cpp -lpqxx -lpq
$ ./a.out
Подключение к базе данных testdb установлено.
```

### Создание таблицы

Приведенный ниже код создаёт таблицу `MYSTORE` в базе данных `testdb`.

```C++
#include <iostream>
#include <pqxx/pqxx> 

using namespace std;
using namespace pqxx;

int main(int argc, char* argv[]) {
   char * sql;
   
   try {
      connection C("dbname = testdb user = postgres password = <пароль> \
      hostaddr = 127.0.0.1 port = 5433");
      if (C.is_open()) {
         cout << "Подключение к базе данных " << C.dbname() << " установлено." << endl;
      } else {
         cout << "Не удаётся установить подключение к базе данных." << endl;
         return 1;
      }

      /* Создать инструкцию SQL */
      sql = "CREATE TABLE MYSTORE("  \
      "ID INT PRIMARY KEY     NOT NULL," \
      "ТИП            TEXT    NOT NULL," \
      "ЦВЕТ           TEXT    NOT NULL," \
      "МАТЕРИАЛ       TEXT    NOT NULL," \
      "ЗАПАС          INT," \
      "ЦЕНА           REAL );";

      /* Создать транзакционный объект */
      work W(C);
      
      /* Выполнить SQL-запрос */
      W.exec( sql );
      W.commit();
      cout << "Таблица создана успешно" << endl;
      C.disconnect ();
   } catch (const std::exception &e) {
      cerr << e.what() << std::endl;
      return 1;
   }

   return 0;
}
```

Скомпилируйте и выполните программу. Вы увидите следующее:

```Bash
$ gсс test.cpp -lpqxx -lpq
$ ./a.out
Подключение к базе данных testdb установлено.
Таблица создана успешно
```

### Операция INSERT

Приведенный ниже код создает записи в таблице `MYSTORE`:

```C++
#include <iostream>
#include <pqxx/pqxx> 

using namespace std;
using namespace pqxx;

int main(int argc, char* argv[]) {
   char * sql;
   
   try {
      connection C("dbname = testdb user = postgres password = <пароль> \
      hostaddr = 127.0.0.1 port = 5433");
      if (C.is_open()) {
         cout << "Подключение к базе данных " << C.dbname() << " установлено." << endl;
      } else {
         cout << "Не удаётся установить подключение к базе данных." << endl;
         return 1;
      }

      /* Создать инструкцию SQL */
      sql = "INSERT INTO MYSTORE (ID,ТИП,ЦВЕТ,МАТЕРИАЛ,ЗАПАС,ЦЕНА) "  \
         "VALUES (1, 'Футболка', 'Синий', 'Хлопок', 500, 2000.00 ); " \
         "INSERT INTO MYSTORE (ID,ТИП,ЦВЕТ,МАТЕРИАЛ,ЗАПАС,ЦЕНА) "  \
         "VALUES (2, 'Футболка', 'Желтый', 'Хлопок', 500, 2000.00 ); " \
         "INSERT INTO MYSTORE (ID,ТИП,ЦВЕТ,МАТЕРИАЛ,ЗАПАС,ЦЕНА) "  \
         "VALUES (3, 'Футболка', 'Красный', 'Хлопок', 500, 2000.00 ); " \
         "INSERT INTO MYSTORE (ID,ТИП,ЦВЕТ,МАТЕРИАЛ,ЗАПАС,ЦЕНА) "  \
         "VALUES (4, 'Рубашка', 'Синий', 'Шелк', 400, 2500.00 ); " \
         "INSERT INTO MYSTORE (ID,ТИП,ЦВЕТ,МАТЕРИАЛ,ЗАПАС,ЦЕНА) "  \
         "VALUES (5, 'Рубашка', 'Белый', 'Хлопок', 600, 1400.00 ); " \
         "INSERT INTO MYSTORE (ID,ТИП,ЦВЕТ,МАТЕРИАЛ,ЗАПАС,ЦЕНА) "  \
         "VALUES (6, 'Свитер', 'Синий', 'Шерсть', 100, 4000.00 ); " \
         "INSERT INTO MYSTORE (ID,ТИП,ЦВЕТ,МАТЕРИАЛ,ЗАПАС,ЦЕНА) "  \
         "VALUES (7, 'Футболка', 'Синий', 'Нейлон', 500, 1000.00 ); "; \
         
      /* Создать транзакционный объект */
      work W(C);
      
      /* Выполнить SQL-запрос */
      W.exec( sql );
      W.commit();
      cout << "Записи созданы успешно." << endl;
      C.disconnect ();
   } catch (const std::exception &e) {
      cerr << e.what() << std::endl;
      return 1;
   }

   return 0;
}
```

Скомпилируйте и выполните программу. Вы увидите следующее:

```Bash
$ gсс test.cpp -lpqxx -lpq
$ ./a.out
Подключение к базе данных testdb установлено.
Записи созданы успешно.
```

### Операция SELECT

Приведенный ниже код выводит на экран записи из таблицы `MYSTORE`:

```C++
#include <iostream>
#include <pqxx/pqxx> 

using namespace std;
using namespace pqxx;

int main(int argc, char* argv[]) {
   char * sql;
   
   try {
      connection C("dbname = testdb user = postgres password = <пароль> \
      hostaddr = 127.0.0.1 port = 5433");
      if (C.is_open()) {
         cout << "Подключение к базе данных " << C.dbname() << " установлено." << endl;
      } else {
         cout << "Не удаётся установить подключение к базе данных." << endl;
         return 1;
      }

      /* Создать инструкцию SQL */
      sql = "SELECT * from MYSTORE";

      /* Создать нетранзакционный объект */
      nontransaction N(C);
      
      /* Выполнить SQL-запрос */
      result R( N.exec( sql ));
      
      /* Вывести записи */
      for (result::const_iterator c = R.begin(); c != R.end(); ++c) {
         cout << "ID = " << c[0].as<int>() << endl;
         cout << "Тип = " << c[1].as<string>() << endl;
         cout << "Цвет = " << c[2].as<string>() << endl;
         cout << "Материал = " << c[3].as<string>() << endl;
         cout << "Запас = " << c[4].as<int>() << endl;
         cout << "Цена = " << c[5].as<float>() << endl;
         cout << endl;
      }
      cout << "Операция выполнена успешно." << endl;
      C.disconnect ();
   } catch (const std::exception &e) {
      cerr << e.what() << std::endl;
      return 1;
   }

   return 0;
}
```

Скомпилируйте и выполните программу. Вы увидите следующее:

```Bash
$ gсс test.cpp -lpqxx -lpq
$ ./a.out
Подключение к базе данных testdb установлено.
ID = 1
Тип = Футболка
Цвет = Синий
Материал = Хлопок
Запас = 500
Цена = 2000

ID = 2
Тип = Футболка
Цвет = Желтый
Материал = Хлопок
Запас = 500
Цена = 2000

ID = 3
Тип = Футболка
Цвет = Красный
Материал = Хлопок
Запас = 500
Цена = 2000

ID = 4
Тип = Рубашка
Цвет = Синий
Материал = Шелк
Запас = 400
Цена = 2500

ID = 5
Тип = Рубашка
Цвет = Белый
Материал = Хлопок
Запас = 600
Цена = 1400

ID = 6
Тип = Свитер
Цвет = Синий
Материал = Шерсть
Запас = 100
Цена = 4000

ID = 7
Тип = Футболка
Цвет = Синий
Материал = Нейлон
Запас = 500
Цена = 1000

Операция выполнена успешно.
```

### Операция UPDATE

Приведенный ниже код изменяет данные в таблице `MYSTORE` с помощью операции `UPDATE` и выводит на экран обновленные записи:

```C++
#include <iostream>
#include <pqxx/pqxx> 

using namespace std;
using namespace pqxx;

int main(int argc, char* argv[]) {
   char * sql;
   
   try {
      connection C("dbname = testdb user = postgres password = <пароль> \
      hostaddr = 127.0.0.1 port = 5433");
      if (C.is_open()) {
         cout << "Подключение к базе данных " << C.dbname() << " установлено." << endl;
      } else {
         cout << "Не удаётся установить подключение к базе данных." << endl;
         return 1;
      }
      
      /* Создать транзакционный объект */
      work W(C);

      /* Создать инструкцию SQL */
      sql = "UPDATE MYSTORE set ЦЕНА = 999.99 where МАТЕРИАЛ='Хлопок'";

      /* Выполнить SQL-запрос */
      W.exec( sql );
      W.commit();
      cout << "Записи изменены успешно" << endl;
      
      /* Создать инструкцию SQL */
      sql = "SELECT * from MYSTORE";

      /* Создать нетранзакционный объект */
      nontransaction N(C);
      
      /* Выполнить SQL-запрос */
      result R( N.exec( sql ));
      
      /* Вывести записи */
      for (result::const_iterator c = R.begin(); c != R.end(); ++c) {
         cout << "ID = " << c[0].as<int>() << endl;
         cout << "Тип = " << c[1].as<string>() << endl;
         cout << "Цвет = " << c[2].as<string>() << endl;
         cout << "Материал = " << c[3].as<string>() << endl;
         cout << "Запас = " << c[4].as<int>() << endl;
         cout << "Цена = " << c[5].as<float>() << endl;
         cout << endl;
      }
      cout << "Операция выполнена успешно." << endl;
      C.disconnect ();
   } catch (const std::exception &e) {
      cerr << e.what() << std::endl;
      return 1;
   }

   return 0;
}

```

Скомпилируйте и выполните программу. Вы увидите следующее:

```Bash
$ gсс test.cpp -lpqxx -lpq
$ ./a.out
Подключение к базе данных testdb установлено.
Записи обновлены успешно.
ID = 4
Тип = Рубашка
Цвет = Синий
Материал = Шелк
Запас = 400
Цена = 2500

ID = 6
Тип = Свитер
Цвет = Синий
Материал = Шерсть
Запас = 100
Цена = 4000

ID = 7
Тип = Футболка
Цвет = Синий
Материал = Нейлон
Запас = 500
Цена = 1000

ID = 1
Тип = Футболка
Цвет = Синий
Материал = Хлопок
Запас = 500
Цена = 999.99

ID = 2
Тип = Футболка
Цвет = Желтый
Материал = Хлопок
Запас = 500
Цена = 999.99

ID = 3
Тип = Футболка
Цвет = Красный
Материал = Хлопок
Запас = 500
Цена = 999.99

ID = 5
Тип = Рубашка
Цвет = Белый
Материал = Хлопок
Запас = 600
Цена = 999.99

Операция выполнена успешно.
```

### Операция DELETE

Приведенный ниже код удаляет данные из таблицы `MYSTORE` с помощью операции `DELETE` и выводит на экран обновленные записи:

```C++
#include <iostream>
#include <pqxx/pqxx> 

using namespace std;
using namespace pqxx;

int main(int argc, char* argv[]) {
   char * sql;
   
   try {
      connection C("dbname = testdb user = postgres password = <пароль> \
      hostaddr = 127.0.0.1 port = 5433");
      if (C.is_open()) {
         cout << "Подключение к базе данных " << C.dbname() << " установлено." << endl;
      } else {
         cout << "Не удаётся установить подключение к базе данных." << endl;
         return 1;
      }
      
      /* Создать транзакционный объект */
      work W(C);

      /* Создать инструкцию SQL */
      sql = "DELETE from MYSTORE where МАТЕРИАЛ != 'Хлопок'";

      /* Выполнить SQL-запрос */
      W.exec( sql );
      W.commit();
      cout << "Записи изменены успешно." << endl;
      
      /* Создать инструкцию SQL */
      sql = "SELECT * from MYSTORE";

      /* Создать нетранзакционный объект */
      nontransaction N(C);
      
      /* Выполнить SQL-запрос */
      result R( N.exec( sql ));
      
      /* Вывести записи */
      for (result::const_iterator c = R.begin(); c != R.end(); ++c) {
         cout << "ID = " << c[0].as<int>() << endl;
         cout << "Тип = " << c[1].as<string>() << endl;
         cout << "Цвет = " << c[2].as<string>() << endl;
         cout << "Материал = " << c[3].as<string>() << endl;
         cout << "Запас = " << c[4].as<int>() << endl;
         cout << "Цена = " << c[5].as<float>() << endl;
         cout << endl;
      }
      cout << "Операция выполнена успешно." << endl;
      C.disconnect ();
   } catch (const std::exception &e) {
      cerr << e.what() << std::endl;
      return 1;
   }

   return 0;
}
```

Скомпилируйте и выполните программу. Вы увидите следующее:

```Bash
$ ./delete.out
Подключение к базе данных testdb установлено.
Записи изменены успешно.
ID = 1
Тип = Футболка
Цвет = Синий
Материал = Хлопок
Запас = 500
Цена = 999.99

ID = 2
Тип = Футболка
Цвет = Желтый
Материал = Хлопок
Запас = 500
Цена = 999.99

ID = 3
Тип = Футболка
Цвет = Красный
Материал = Хлопок
Запас = 500
Цена = 999.99

ID = 5
Тип = Рубашка
Цвет = Белый
Материал = Хлопок
Запас = 600
Цена = 999.99

Операция выполнена успешно.
```

## Использование программного продукта

Pangolin может использоваться как СУБД широкого профиля и выполнять любые задачи, стоящие перед современными системами хранения и обработки данных, однако функциональные особенности системы, такие как расширенные средства обеспечения безопасности, контроля доступа и защиты пользовательских данных, превращают Pangolin в надежное решение для таких сфер деятельности, где конфиденциальность и сохранность данных имеют первостепенное значение, а их утрата или кража могут обернуться катастрофическими финансовыми и репутационными потерями и даже привести к уголовной ответственности.

В число приоритетных для Pangolin секторов экономики входят:

-   банковская и финансовая сферы,
-   государственные информационные системы и сети,
-   здравоохранение.

Внедрение Pangolin в организации, принадлежащие к этим отраслям, приведет к повышению уровня безопасности обрабатываемой информации и снизит риски её хищения или утраты.