# Руководство системного администратора Platform V Pangolin

Platform V Pangolin - система управления базами данных, основанная на PostgreSQL. В этом документе описываются аспекты Pangolin, связанные с администрированием системы.

Этот документ предназначен для системных администраторов продукта, не осуществляющих обслуживание и настройку системы.

## Ролевая модель и права доступа
Для обеспечения контроля доступа к защищаемым элементам системы применяется система разграничения доступа, основанная на ролях.

Ролевая модель этой системы выглядит следующим образом:

| Роль | Объект доступа | Право (тип доступа) |
|---|---|---|
| Администратор безопасности<br><br><br><br><br><br><br><br><br><br><br><br><br><br> | База данных | Подключение к БД |
|  |  | Инициализация механизма защиты |
|  | Объекты БД | Право на помещение объекта БД под защиту механизма защиты (не RBAC!) |
|  |  | Право на снятие защиты механизма защиты (не RBAC!) с объекта БД |
|  | Политики доступа к объектам БД | Право на создание политик доступа механизма защиты (не RBAC!) к объектам БД |
|  |  | Право на управление составом разрешений в политиках доступа механизма защиты (не RBAC!) |
|  |  | Право на назначение и изъятие политик доступа механизма защиты (не RBAC!) у пользователей БД, включая администратора БД |
|  | Пользователи и роли БД | Право на назначение пользователя администратором безопасности механизма защиты (не RBAC!) |
|  |  | Право на снятие с пользователя роли администратора безопасности механизма защиты (не RBAC!) |
|  | Правила аутентификации | Право управления правилами аутентификации пользователей в защищенном хранилище (внешнее относительно Pangolin) в режиме защищенного конфигурирования |
|  | Настройки БД | Право управления настройками БД в защищенном хранилище (внешнее относительно Pangolin) в режиме защищенного конфигурирования |
|  |  | Право настройки параметров подключения БД к защищенному хранилищу (внешнее относительно Pangolin) |
|  | Функции мониторинга параметров безопасности | Право на вызов функций мониторинга параметров безопасности |
|  | Журнал аудита | Определяется правами ОС |
|  | Ключи шифрования Transparent Data Encryption | Право на выполнение ротации мастер-ключа шифрования |
|  |  | Право на установку мастер-ключа шифрования |
|  |  | Право на выполнение перешифрования набора ключей шифрования |
|  |  | Право на выполнение восстановления набора ключей шифрования после сбоя |
| Администратор БД | Пользователи и роли БД | Полный доступ, за исключением пользователей и ролей, находящихся под защитой механизма защиты, включая:<br>- создание<br>- удаление<br>- изменение параметров пользователя или роли<br>- изменение прав в RBAC<br>- организация иерархии ролей в RBAC<br>,исключая:<br>- назначение пользователя администратором безопасности механизма защиты<br>- снятие с пользователя прав администратора безопасности механизма защиты<br>- управление политиками доступа механизма защиты для пользователя<br><br>Для пользователей и ролей, находящихся под защитой механизма защиты, набор разрешенных действий определяется политиками, выданными администратору БД администратором безопасности. |
|  | База данных | Полный доступ |
|  | Табличное пространство | Полный доступ |
|  | Объекты БД | Полный доступ, за исключением объектов, находящихся под защитой механизма защиты.<br><br>Для объектов, находящихся под защитой механизма защиты, набор разрешенных действий определяется политиками, выданными администратору БД администратором безопасности. |
|  | Правила аутентификации | Право управления правилами аутентификации пользователей в локальных конфигурационных файлах вне режима защищенного конфигурирования |
|  | Настройки БД | Полный доступ, за исключением<br>- настроек взаимодействия с защищенным хранилищем;<br>- настроек в защищенном хранилище в режиме защищенного конфигурирования |
|  | Парольные политики пользователей | Полный доступ |
|  | Настройки аудита | Полный доступ |
|  | Журнал аудита | Полный доступ |
| Пользователь БД | Пользователи и роли БД | В соответствии с правами в RBAC, за исключением пользователей и ролей, находящихся под защитой механизма защиты, исключая<br>- назначение пользователя администратором безопасности механизма защиты<br>- снятие с пользователя прав администратора безопасности механизма защиты<br>- управление политиками доступа механизма защиты для пользователя<br><br>Для пользователей и ролей, находящихся под защитой механизма защиты, набор разрешенных действий определяется политиками, выданными пользователю БД администратором безопасности и разрешениями в рамках RBAC. |
|  | База данных | В соответствии с правами в RBAC |
|  | Табличное пространство | В соответствии с правами в RBAC |
|  | Объекты БД | В соответствии с правами в RBAC, за исключением объектов, находящихся под защитой механизма защиты.<br><br>Для объектов, находящихся под защитой механизма защиты, набор разрешенных действий определяется политиками, выданными пользователю БД администратором безопасности и разрешениями в рамках RBAC. |
|  | Настройки БД | В соответствии с правами в RBAC, за исключением <br>- настроек взаимодействия с защищенным хранилищем;<br>- настроек в защищенном хранилище в режиме защищенного конфигурирования |
|  | Парольные политики пользователей | В соответствии с правами в RBAC |
|  | Настройки аудита | В соответствии с правами в RBAC |

Права доступа пользователей устанавливаются в соответствии с ролевой моделью.

### Операции, которые не должны выполняться одним лицом

Следующие операции имеют критическое значение для безопасности, поэтому не могут быть выполнены одним лицом:

1. Выполнение общих настроек, влияющих на возможность несанкицонированного доступа к передаваемой или хранимой информации:
    - настройки защиты сетевых соединений
    - настройки состава загружаемых модулей расширения
    - настройки состава доверенных серверов аутентификации
    - настройки включения прозрачного шифрования данных
 
2. Управление доступом к объектам баз данных, содержащих конфиденциальную или секретную информацию

## Сценарии администрирования

Администрирование Platform V Pangolin осуществляется средствами, которые описаны в этом разделе.

### Реализация АРМ администратора

Для администрирования системы используется утилита `psql`. Эта утилита представляет собой терминальный клиент для передачи запросов к СУБД и отображения результатов.

```SQL
psql [параметр...] [имя_бд [имя_пользователя]]
```

### Интерфейс администратора безопасности Pangolin

Интерфейс администратора безопасности включает в себя следующие функции:

`pm_get_protected_objects ()` - возвращает список объектов, находящихся под защитой

`pm_protect_object` (имя базы данных, типа объекта, наименование объекта) - помещает объект под защиту

`pm_unprotect_object` (имя базы данных, типа объекта, наименование объекта) - снимает защиту с объекта

`pm_make_policy` (имя политики) - создает политику

`pm_grant_to_policy` (имя политики, имя базы данных, типа объекта, наименование объекта, массив действий над объектом) - вносит в политику разрешение на действия над объектом

`pm_revoke_from_policy` (имя политики, имя базы данных, типа объекта, наименование объекта, массив действий над объектом) - исключает из политики разрешения на действия над объектом

`pm_assign_policy_to_user` (имя пользователя, имя политики) - назначает политику пользователю

`pm_unassign_policy_from_user` (имя пользователя, имя политики) - изымает политику у пользователя

`pm_get_assigned_policies` (имя пользователя) - получает список политик, назначенных пользователю

`pm_get_policy_grants` (имя политики) - получает список разрешений в составе политики

`pm_get_policies` () - получает список политик

`pm_grant_security_admin` (имя пользователя) - делает пользователя администратором безопасности

`pm_revoke_security_admin` (имя пользователя) - снимает с пользователя политики администратора безопасности

### Интерфейс управления парольными политиками: PL/pgSQL API

Все запросы к базе выполняются через SPI интерфейс (т.е. не через внутренний API АС Platform V Pangolin), так как вероятность изменения SQL интерфейса меньше.

#### Сценарии работы с механизмом

Большинство операций выполняется соответствующими функциями PL/pgSQL:

-   создание парольной политики;
-   активация парольной политики;
-   деактивация парольной политики;
-   отобразить парольные политики, примененные к роли;
-   отобразить все активные политики;
-   разблокировать роль.

##### Создать новую политику

Последовательно выполните функции:

1.  Создания парольной политики;

> Если какая-либо настройка политики не задана, то её значение берётся из конфигурационного файла.

1.  Активации парольной политики.

##### Разблокировать роль

Выполняется соответствующей SQL функцией.

##### Активировать или деактивировать политику

Выполняется соответствующими SQL функциями:

-   активация парольной политики;
-   деактивация парольной политики.

##### Изменить настройки политики

Выполняется соответствующей SQL-функцией. При изменении параметров учитывайте зависимости между ними и изменяемую функциональность. Нельзя изменить параметр: roloid.

##### Сменить политику для роли

Роли связаны с политиками по идентификатору роли. Изменить политику для роли можно следующими способами:

-   удалить старую политику и создать новую политику;
-   включить роль в другую роль с нужной политикой.

##### Подключение модуля

Подключение модуля возможно исключительно через параметр `shared_preload_libraries` в файле конфигурации `postgresql.conf`. Это связано с использованием собственных общедоступных кэшей - их возможно создать, только изменив процесс инициализации `relation cache` фазы 2 и инициализации кэшей `catcache` фазы 2.

Изменение параметров конфигурации возможно стандартным путем - `pg_ctl reload`.

#### Вывод парольной политики, примененной для пользователя или роли

Вывод политики, приписанной этой роли

*Формат*

* `recognize_password_policy(name role_name)` - по имени роли
* `recognize_password_policy_by_role_id(oid roleid)` - по идентификатору роли

*Входные атрибуты*

* `role_name` – имя роли
* `role_id` – идентификатор роли

*Возвращаемое значение*

* Кортеж с описание политики.

#### Вывод детализированной информации по примененной парольной политики для пользователя или роли

Вывод эффективной политики, получившейся в сценарии (выбор политики для пользователя) с указанием какая политика из какой роли (или из postgresql.conf) действует.

*Формат*

* `recognize_password_policy_detailed(name role_name)` - по имени роли
* `recognize_password_policy_detailed_by_role_id(oid roleid)`- по идентификатору роли

*Входные атрибуты*

* `role_name` – имя роли
* `role_id` – идентификатор роли

*Возвращаемое значение*

* Кортеж с политикой с полями, указывающими роль (или строку config) для каждой политики.

### Авторизация и аутентификация

Pangolin поддерживает несколько типов авторизации и аутентификации пользователей и сервисов:

* trust - **Не рекомендуется**

    Любой пользователь, подключающийся к серверу, авторизован для доступа

* password - **Не рекомендуется**

    Авторизация с помощью пароля, передаваемого в виде хэша MD5 или открытым текстом

* GSSAPI

    Протокол авторизации по стандарту RFC 2743

* SSPI

    Технология защищенной аутентификации Windows - **Не поддерживается на рекомендованной ОС**

* ident - **Не рекомендуется**

    Аутентификация с использованием сервера `ident` по стандарту RFC 1413

* peer - **Не рекомендуется**

    Получение имени пользователя клиента из ядра и использование его в качестве авторизованного имени пользователя БД

* LDAP

    Аналогично `password`, но для подтверждения пары "имя пользователя / пароль" используется метод LDAP

* RADIUS

    Аналогично `password`, но для подтверждения пары "имя пользователя / пароль" используется метод RADIUS

* Аутентификация по сертификату

    Аутентификация с использованием клиентского сертификата SSL. Применимо только для SSL-подключений

* PAM

    Аналогично `password`, но для подтверждения пары "имя пользователя / пароль" используется метод PAM. Также поддерживается проверка имени и IP удаленного компьютера

* BSD

    Аналогично `password`, но для подтверждения пары "имя пользователя / пароль" используется метод BSD

#### Защита аутентификационной информации

В Platform V Pangolin реализована защита аутетификационной информации в процессе ее ввода.При аутентификации через утилиту `psql` вводимые пользователем символы пароля не отображаются.

Перечисленные ниже способы аутентификации передают аутентификационную информацию в открытом виде:
* Файл `pgpass`
* Строки параметров подключения (Connection string)
* Переменная окружения `PGPASSWORD`

Эти способы аутентификации использовать не рекомендуется.

### Архивирование и восстановление
Для архивирования и восстановления используется *Подсистема резервного копирования и репликации*. Она включает в себя утилиты для резервного копирования и восстановления, например, `pg_probackup`, а также для потоковой и логической репликации.

### Управление учетными записями

Учетные записи пользователей и технические учетные записи создаются, удаляются и изменяются администраторами безопасности и администраторами Pangolin.

Разрешения для учетных записей регулируются политиками, которые определяют права доступа той или иной роли к объектам базы данных.

Парольные политики описываются в разделе "Интерфейс управления парольными политиками: PL/pgSQL API".

### Разграничение доступа к данным (включая функции маскирования, хэширования и т.п)

В этом разделе описываются механизмы разграничения доступа к данным.

#### Управление доступом на уровне ролей (RBAC)

Система ограничивает доступ пользователей к объектам БД в зависимости от их роли и привилегий, которые назначены для этой роли.

#### Row level security

Механизм ограничения доступа пользователей к отдельным строкам в таблицах.

#### Защита от привилегированных пользователей

В Platform V Pangolin используется механизм защиты данных от привилегированных пользователей, построенный на принципе разделения ролей. 

В стандартном PostgreSQL привилегированные пользователи имеют доступ к объектам БД и настройкам подключения:
- Администраторы БД имеют произвольный доступ к любым пользовательским данным, что может привести к утечкам конфиденциальной информации.
- Администраторы ОС могут менять настройки БД таким образом, чтобы получать доступ к пользовательским данным, что тоже ведет к утечкам.

В Platform V Pangolin Администраторы БД и ОС теряют возможность самостоятельно управлять некоторыми параметрами и перестают иметь полный доступ ко всем объектам БД. 

В дополнение к роли суперпользователя, которая есть в стандартной версии PostgreSQL, в Pangolin можно создать специальную роль Администратора безопасности (АБ).

АБ – независимый администратор, не обладающий особыми правами в операционной системе (в том числе не имеющий прав Linux-пользователя postgres) и не имеющий доступа к объектам БД. Внутри БД роль Администратора безопасности является особенной в том смысле, что она не может быть изменена суперпользователем.

Таким образом, ни один из пользователей не может единолично получить доступ к конфиденциальным данным или изменять важные для безопасности настройки БД и права доступа.

### Автоматическое завершение неактивных соединений

Соединения, остающиеся неактивными определенное время, подлежат принудительному завершению.
Для завершения таких соединений используется фоновый процесс, осуществляющий мониторинг и завершение бездействующих клиентских сеансов. Этот процесс запускается при старте сервера Pangolin и завершается вместе с остановкой сервера.

Процесс регулируется двумя параметрами:

* `check_idle_time_delay` - интервал мониторинга в миллисекундах,

* `backend_idle_alive_time` - допустимое время бездействия в секундах.

Если хотя бы один из этих параметров равен нулю, неактивные соединения завершаться не будут.

### HashiCorp Vault

Решение HashiCorp Vault используется в качестве защищенного хранилища ключей шифрования и настроек, а также как система управления ключами.

#### Настройка подключения

В системе используются механизм защиты данных от привелегированных пользователей и механизм прозрачного шифрования данных. Их функционирование описывается в соответствующих разделах.
Оба механизма используют сервис управления ключами (KMS).

В обязанности администратора безопасности входит настройка соединения со службой управления ключами (KMS). Если на сервере настроены параметры KMS, то при выполнении команды `initdb` происходит конфликт между параметрами локальной и удаленной конфигурации.
Чтобы восстановить возможность инициализировать новые базы данных, переместите или удалите файл `/etc/postgres/enc_connection_settings.cfg`.

Настройка соединения с KMS осуществляется через утилиту `setup_kms_credentials`:

1. Запустите `setup_kms_credentials` на экземпляре СУБД Pangolin

2. Вы увидите сообщение с предложением выбрать, для какого домена задать идентификационные данные: KMS или POSTGRESQL. Выберите первый вариант.

```
    Choose credentials domain:
    1. KMS					<-
    2. POSTGRESQL
```

3. Вы увидите сообщение с предложением указать ID кластера PostgreSQL:

```
    Enter PostgreSQL cluster ID:
    2						<-
```

4. Вы увидите сообщение с предложением указать IP-адрес и порт KMS:

```
    Enter IP address:
    10.53.116.39				<-
    Enter port:
    82002						<-
```

5. Вы увидите сообщение с предложением выбрать метод аутентификации: Userpass или AppRole. Выберите первый вариант.

```
    Choose credentials type:
    1. Userpass Auth Method	<-
    2. AppRole Auth Method
```

6. Вы увидите предложение указать логин и пароль и подтвердить пароль:

```
    Enter login:
    adminencryption			<-
    Enter password:
    ****					<-
    Confirm password:
    ****					<-
```

7. Вы увидите предложение добавить настройки для еще одного KMS:

```
    Do you want to add another KMS credentials? (yes/no)?:
    no						<-
```

8. Если установка идентификационных данных выполнена успешно, вы увидите следующее сообщение:

```
    Credentials for KMS has been set successfully
```

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Если при установке возникли проблемы, воспользуйтесь командой:

```
    setup_kms_credentials --help
```

9. Установите необходимые права доступа на созданный файл настроек. Для этого введите в консоли команду:

```
    $ chmod 600 /etc/postgres/enc_connection_settings.cfg
```

Настройка соединения с системой управления ключами завершена.

### Средства криптографической защиты информации

Для использования шифрования между клиентом и сервером необходимо настроить `OpenSSL` на клиенте и на сервере. 

SSL включается с помощью парметра `ssl = on` в файле `postgresql.conf`.

SSL использует файлы сертификата и закрытого ключа сервера. По умолчанию они называются `server.crt` и `server.key`. Эти названия менять не рекомендуется.

Доступ к файлу `server.key` должен быть ограничен командой `chmod 0600 server.key`.

Чтобы клиенты могли подключаться к серверу с помощью сертификатов, поместите сертификаты корневых центров сертификации в каталог `data`, укажите имя файла с сертификатами в параметре `ssl_ca_file` в `postgresql.conf`.

После этого добавьте параметр `clientcert=1` в соответствующие строки `hostssl` в файле `pg_hba.conf`.

### Снятие резервной копии со standby-базы

Функция резервного копирования позволяет снять с базы данных архивную копию, которую в дальнейшем можно использовать для восстановления. PostgreSQL поддерживает создание резервной копии как с главного сервера, так и с реплики.

Резервное копирование выполняется следующей командой:

`PGPASSWORD={backup_pass} pg_probackup backup -B {PGBACKUP} --instance {cluster_name} -b FULL`

Восстановление из резервной копии выполняется следующей командой:

`pg_probackup restore -B {PGBACKUP} --instance {cluster_name} --recovery-target='latest`

Процедуры резервного копирования на главном сервере и на копии принципиально идентичны.

## События системного журнала

Действия, выполняемые системой Pangolin, фиксируются в системном журнале.

Подробная информация о реализации системного журнала приведена в разделе **pgAudit**.

## События мониторинга

События, подлежащие мониторингу, фиксируются в системном журнале.

Подробная информация о реализации системного журнала приведена в разделе **pgAudit**.

## pgAudit

Для журналирования и аудита событий безопасности используется модифицированное расширение `pgAudit`. Оно обеспечивает детальное журналирование сессий и объектов для целей аудита. События подключения и события настройки механизма защиты данных в отдельные классы регистрируемых событий для предоставления возможности гибкой настройки аудита. `pgAudit` заменяет стандартное средство журналирования PostgreSQL.


### Формат

Записи аудита записываются в стандартное средство ведения журнала и содержат следующие столбцы в формате CSV. Выходные данные соответствуют формату CSV только в том случае, если префикс строки журнала каждой записи удален.

-   **AUDIT\_TYPE** - `SESSION` или `OBJECT`.

-   **STATEMENT\_ID** - Уникальный идентификатор оператора для этой сессии. Каждый идентификатор оператора представляет собой внутренний вызов. Идентификаторы операторов идут последовательно, даже если некоторые операторы не регистрируются. Когда регистрируется более одного отношения, для одного идентификатора оператора может быть несколько записей.

-   **SUBSTATEMENT\_ID** - Последовательный идентификатор для каждого вложенного оператора в основном операторе. Например, вызов функции из запроса. Идентификаторы вложенных операторов идут последовательно, даже если некоторые вложенные операторы не регистрируются. Когда регистрируется более одного отношения, для одного идентификатора вложенного оператора может быть несколько записей.

-   **CLASS** - `READ`, `ROLE` и т.д. (см. раздел `pgaudit.log`).

-   **COMMAND** - `ALTER TABLE`, `SELECT` и т.д.

-   **OBJECT\_TYPE** - `TABLE`, `INDEX`, `VIEW` и т.д. Применимо для `SELECT`, `DML` и большинства `DDL`.

-   **OBJECT\_NAME** - Полное имя объекта (например, `public.account`). Применимо для `SELECT`, `DML` и большинства `DDL`.

-   **STATEMENT** - Операция, выполняемая на сервере.

-   **PARAMETER** - Если параметр pgaudit.log\_parameter включен, здесь в кавычках будут перечислены параметры в формате CSV. Если параметров нет, здесь будет `<none>`. Иначе в этом поле будет запись `<not logged>`.

-   **EXECUTION\_RESULT** - Если операция завершается с ошибкой, вызванной недостаточными привилегиями или механизмом защиты от привилегированных пользователей, в этом поле будет запись `ERROR: INSUFFICIENT PRIVILEGE`. Если операция выполнена успешно и оператор принадлежит к классу `PROTECTION`, в поле заносится запись `SUCCESS`.

У записей класса `CONNECTION` собственный формат.

-   **AUDIT\_TYPE** - Всегда `SESSION`.

-   **CLASS** - Всегда `CONNECTION`.

-   **EVENT** - `OPEN`, `CLOSED`, `FAILED`, `CHANGE USE`R.

-   **SESSION\_TIME** - Только для события `CLOSED`. Формат записи: "`session time: %d:%02d:%02d.%03d`" - часы, минуты, секунды, миллисекунды соответственно.

-   **DATA\_BASE** - Имя базы данных, к которой осуществляется подключение. Формат записи: - "`database = %s`" (имя базы данных).

-   **USER** - Имя пользователя, подключающегося к базе данных. Формат записи: - "`user = %s`" (имя пользователя).

Для добавления любых других полей, необходимых для удовлетворения ваших требований к журналу аудита, может использоваться префикс строки журнала ([log\_line\_prefix](http://www.postgresql.org/docs/11/static/runtime-config-logging.html#GUC-LOG-LINE-PREFIX)). Пример префикса строки журнала: "`%m %u %d \[%p\]:`" - включить дату/время, имя пользователя, имя базы данных и идентификатор процесса для каждой записи журнала аудита.

### Рекомендации

В зависимости от настроек журнал pgAudit может достигать очень больших объемов. Следует максимально точно определить, что именно должно быть записано в журнал аудита в вашей среде, чтобы избежать слишком большого количества записей.

Например, при работе в среде OLAP, вероятно, было бы неразумно проверять вставки журналов в большую таблицу фактов. Размер файла журнала, скорее всего, будет во много раз больше фактического размера данных вставок, поскольку файл журнала хранится в текстовом виде. Поскольку журналы обычно хранятся на диске вместе с ОС, это может привести к очень быстрому исчерпанию дискового пространства. В тех случаях, когда невозможно ограничить ведение журнала аудита определенными таблицами, обязательно оцените влияние на производительность во время тестирования и выделите достаточно места на томе журнала. Это также может быть верно для сред OLTP. Даже если объем операций вставки не так высок, влияние журнала аудита на производительность все равно может привести к заметному росту задержки.

Чтобы ограничить количество записей аудита отношений для операторов `SELECT` и `DML`, рассмотрите возможность использования журнала аудита объектов (см. раздел Аудит объектов). Ведение журнала аудита объектов позволяет выбрать отношения, которые будут регистрироваться, что позволяет уменьшить общий объем журнала. Однако все новые создаваемые отношения должны быть явно добавлены в журнал аудита объектов. В этом случае хорошим вариантом может быть программное решение, в котором некоторые определенные таблицы исключаются из ведения журнала, а все остальные включаются.


Настройки `pgAudit` могут быть изменены только суперпользователем. Если разрешить обычным пользователям изменять свои настройки, то ведение журнала аудита теряет смысл.

Настройки могут быть заданы глобально (в файле `postgresql.conf` или с помощью `ALTER SYSTEM ... SET)`, на уровне базы данных (с помощью `ALTER DATABASE ... SET`) или на уровне роли (с помощью `ALTER ROLE ... SET`). Обратите внимание, что настройки не наследуются через обычное наследование ролей, и `SET ROLE` не изменит настройки pgAudit пользователя. Это ограничение системы ролей, а не особенность pgAudit.

Расширение pgAudit должно быть загружено в [shared\_preload\_libraries](http://www.postgresql.org/docs/11/static/runtime-config-client.html#GUC-SHARED-PRELOAD-LIBRARIES). В противном случае во время загрузки возникнет ошибка, и ведение журнала аудита не будет происходить. Кроме того, `CREATE EXTENSION pgaudit` следует вызвать до того, как будут заданы параметры `pgaudit.log`. Если расширение удалено и его необходимо воссоздать, то сначала должен быть удален `pgaudit.log`, иначе возникнет ошибка.

### pgaudit.log

Указывает, какие классы операторов будут регистрироваться при ведении журнала аудита сессии. Возможные значения:

-   **READ**: `SELECT `и `COPY`, если источник - отношение или запрос.

-   **WRITE**: `INSERT`, `UPDATE`, `DELETE`, `TRUNCATE` и `COPY`, если цель - отношение.

-   **FUNCTION**: Вызовы функций и блоки `DO`.

-   **ROLE**: Операторы, связанные с ролями и привилегиями: `GRANT`, `REVOKE`, `CREATE/ALTER/DROP ROLE`.

-   **DDL**: Все `DDL`, не входящие в класс `ROLE`.

-   **MISC**: Прочие команды, включая `DISCARD`, `FETCH`, `CHECKPOINT`, `VACUUM`, `SET`.

-   **MISC\_SET**: Прочие команды `SET`, включая `SET ROLE`.

-   **CONNECTION**: События, связанные с подключением к серверу. Существуют 4 типа таких событий: `OPEN`, `CLOSED`, `FAILED`, `CHANGE USER`. Событие `FAILED` регистрируется в случае неудачной попытки аутентификации по паролю и независимо от значения `pgaudit.log`.

-   **PROTECTION**: Функции настройки механизма защиты от привилегированных пользователей.

-   **ALL**: Включить всё вышеперечисленное.

Можно включить несколько классов, перечислив их через запятую, или исключить определенные классы, поставив перед ними знак `-` (см. раздел Журнал аудита сессии).

Значение по умолчанию - `none`.

### pgaudit.log\_catalog

Указывает, должно ли быть включено ведение журнала сессии в том случае, если все отношения в операторе находятся в pg\_catalog. Отключение этого параметра уменьшит шум в журнале от таких инструментов, как psql и pgAdmin, которые часто обращаются к каталогу.

Значение по умолчанию - `on`.

### pgaudit.log\_client

Указывает, будут ли сообщения журнала видны клиентскому процессу - такому, как psql. Этот параметр обычно следует оставлять отключенным, но он может быть полезен для отладки или других целей.

Обратите внимание, что `pgaudit.log\_level` включен только тогда, когда `pgaudit.log\_client` **включен**.

Значение по умолчанию - `off`.

### pgaudit.log\_level

Указывает уровень журналирования, который будет использоваться для записей журнала (см. [Уровни важности сообщений](http://www.postgresql.org/docs/9.4/static/runtime-config-logging.html#RUNTIME-CONFIG-SEVERITY-LEVELS)). Обратите внимание, что значения `ERROR`, `FATAL` и `PANIC` не допускаются). Этот параметр используется для регрессионного тестирования, а также может быть полезен конечным пользователям для тестирования или других целей.

`pgaudit.log\_level` включен только тогда, когда `pgaudit.log\_client` **включен**; в противном случае будет использоваться значение по умолчанию.

Значение по умолчанию - `log`.

### pgaudit.log\_parameter

Указывает, что ведение журнала аудита должно включать параметры, переданные вместе с оператором. При наличии параметров они будут включены в формате `CSV` после текста оператора.

Значение по умолчанию - `off`.

### pgaudit.log\_relation

Указывает, должно ли ведение журнала аудита сессии создавать отдельную запись журнала для каждого отношения (`TABLE`, `VIEW` и т.д.), на которое ссылается оператор `SELECT` или `DML`. Это полезный прием для исчерпывающего ведения журнала без использования журнала аудита объектов.

Значение по умолчанию - `off`.

### pgaudit.log\_statement\_once

Указывает, будут ли текст и параметры оператора прикрепляться к первой записи в журнале для комбинации оператора и вложенных операторов или к каждой записи. Отключение этого параметра приведет к менее подробному ведению журнала, но может затруднить определение оператора, сгенерировавшего запись журнала, хотя пары оператора и вложенного оператора вместе с идентификатором процесса должно быть достаточно для идентификации текста оператора, записанного в предыдущей записи.

Значение по умолчанию - `off`.

### pgaudit.role

Указывает главную роль, используемую для ведения журнала аудита объектов. Можно определить несколько ролей аудита, предоставив их главной роли. Это позволяет нескольким группам отвечать за различные аспекты ведения журнала аудита.

Значения по умолчанию нет.

### Ведение журнала аудита сессии

Журнал аудита сессии предоставляет подробные записи всех операций, выполняемых пользователем на сервере.

#### Конфигурация

Ведение журнала сессии включается с помощью параметра `pgaudit.log`.

Включить ведение журнала сессии для всех `DML` и `DDL` и протоколировать все отношения в операторах DML:

```
set pgaudit.log = 'write, ddl';

set pgaudit.log\_relation = on;
```

Включить ведение журнала сессии для всех команд, кроме `MISC`, и выводить сообщения журнала аудита с пометкой `NOTICE`:
```
set pgaudit.log = 'all, -misc';

set pgaudit.log\_level = notice;
```

#### Пример

В этом примере ведение журнала аудита сессии используется для ведения журнала операторов `DDL` и `SELECT`. Обратите внимание, что оператор `INSERT` не регистрируется, так как класс `WRITE` не включен.

*SQL*:
```SQL
set pgaudit.log = 'read, ddl';

create table account
(
    id int,
    name text,
    password text,
    description text
);

insert into account (id, name, password, description)
             values (1, 'user1', 'HASH1', 'blah, blah');

select *
    from account;
```

*Вывод в журнале*:
```SQL
AUDIT: SESSION,1,1,DDL,CREATE TABLE,TABLE,public.account,create table account
(
    id int,
    name text,
    password text,
    description text
);,<not logged>
AUDIT: SESSION,2,1,READ,SELECT,,,select *
    from account,,<not logged>
```

### Ведение журнала аудита объектов

Журнал аудита объектов регистрирует операторы, влияющие на определенное отношение. Поддерживаются только команды `SELECT`, `INSERT`, `UPDATE` и `DELETE`. `TRUNCATE` не включается в журнал аудита объектов.

Ведение журнала аудита объектов - более подробная альтернатива `pgaudit.log = 'read, write'`. Таким образом, возможно, нет смысла использовать их вместе, но можно, например, использовать ведение журнала сеансов для регистрации каждого оператора, а затем дополнить его ведением журнала объектов, чтобы получить более подробную информацию о конкретных отношениях.

#### Конфигурация

Ведение журнала аудита на уровне объектов осуществляется через систему ролей. Параметр `pgaudit.role` определяет роль, которая будет использоваться для ведения журнала аудита. Отношение (`TABLE`, `VIEW`) будет записываться в журнал аудита, если роль аудита имеет разрешения для выполняемой команды или наследует разрешения от другой роли. Это позволяет эффективно использовать несколько ролей аудита, даже если в любом контексте существует одна главная роль.

Задайте для `pgaudit.role` значение `auditor` и наделите её правами `SELECT` и `DELETE` над таблицей `account`. Теперь операции `SELECT` и `DELETE` над таблицей `account` будут заноситься в журнал:

```SQL
set pgaudit.role = 'auditor';

grant select, delete
   on public.account
   to auditor;
```

#### Пример

В этом примере ведение журнала аудита объектов используется для иллюстрации того, как может быть применен детализированный подход к журналированию операторов `SELECT` и `DML`. Обратите внимание, что ведение журнала операций над таблицей `account` контролируется разрешениями на уровне столбцов, а ведение журнала операций над табицей `account\_role\_map` - на уровне таблиц.

*SQL*:
```SQL
set pgaudit.role = 'auditor';

create table account
(
    id int,
    name text,
    password text,
    description text
);

grant select (password)
   on public.account
   to auditor;

select id, name
  from account;

select password
  from account;

grant update (name, password)
   on public.account
   to auditor;

update account
   set description = 'yada, yada';

update account
   set password = 'HASH2';

create table account_role_map
(
    account_id int,
    role_id int
);

grant select
   on public.account_role_map
   to auditor;

select account.password,
       account_role_map.role_id
  from account
       inner join account_role_map
            on account.id = account_role_map.account_id
```

*Вывод в журнале*:
```SQL
AUDIT: OBJECT,1,1,READ,SELECT,TABLE,public.account,select password
  from account,<not logged>
AUDIT: OBJECT,2,1,WRITE,UPDATE,TABLE,public.account,update account
   set password = 'HASH2',<not logged>
AUDIT: OBJECT,3,1,READ,SELECT,TABLE,public.account,select account.password,
       account_role_map.role_id
  from account
       inner join account_role_map
            on account.id = account_role_map.account_id,<not logged>
AUDIT: OBJECT,3,1,READ,SELECT,TABLE,public.account_role_map,select account.password,
       account_role_map.role_id
  from account
       inner join account_role_map
            on account.id = account_role_map.account_id,<not logged>
            
```

## Часто встречающиеся проблемы и пути их устранения

**Проблема:**

Обрыв сети между ЦОД.

**Рекомендация:**

-   размещение HAProxy за пределами КТС с СУБД;
-   дублирование экземпляров `HAProxy`;
-   добавление в схему решений, реализующих VRRP или аналоги - BGP.

**Проблема:**

При использовании асинхронной репликации, в случае частичного обрыва сети на `Active` (запросы от клиентов продолжают поступать на `Active`), в результате срабатывания `AutoFailOver` может возникнуть ситуация, называемая `Split Brain`. До срабатывания `ttl` изолированный экземпляр PostgreSQL продолжает обрабатывать клиентские запросы в режиме `Active`. Если восстановление сети произойдет после срабатывания `ttl` (смена ролей `Active/StandBy`), то на "старом" `Active` будет выполнена команда `pg_rewind`, в результате которой будут отменены все транзакции примененные в период с момента разрыва до срабатывания `ttl`.

**Рекомендации:**

-   использовать режим синхронной репликации;
-   реализовать `callback` в скриптах `patroni` для переключения `Active` в `StandBy` при разрыве сети (без ожидания срабатывания `ttl`);

**Проблема:**

Если в рамках описанного выше сценария отключить использование `pg_rewind`, то добавленные до истечения `ttl` транзакции не удаляются, но и не реплицируются на "новый" `Active`, после восстановления соединения. Аналогичное поведение наблюдается и при синхронной репликации.

**Рекомендации:**

-   перенос данных на новый `Active` (возможно, `pg_receivewal`), с проработкой вопроса "мёрджа" данных в случае конфликтов.

**Проблема:**

Если в рамках описанного выше сценария будет использована синхронная репликация, то запросы на "старом" `Active` будут висеть, не завершаясь, при этом транзакции на нем будут применены. После восстановления соединения транзакции откатываются `pg_rewind`.

**Рекомендации:**

-   реализовать на стороне клиента защитный механизм с таймаутами (в случаях срабатывания таймаута откатывать текущую транзакцию);
-   не применять транзакцию в случае невозможности репликации.

**Проблема:**

При использования строгой синхронной репликации и недоступности `StandBy` запрос на `Active` висит, не завершаясь. Запись в базу добавляется после сигнала прерывания, либо при восстановлении связи со `StandBy`. Репликация отрабатывает после восстановления связи с `StandBy`.

**Рекомендации:**

-   реализовать на стороне клиента защитный механизм с таймаутами (в случаях срабатывания таймаута - откатывать текущую транзакцию);
-   добавить в схему второй `StandBy`, настроенный на асинхронное реплицирование с синхронным `StandBy`;
-   не применять транзакцию в случае невозможности репликации.

**Проблема:**

В случае аварийного завершения сервиса `patroni` на `Active` во всех режимах работы есть вероятность потери транзакций в результате работы `pg_rewind`.

**Рекомендации:**

-   использовать схему с автоматическим переключением трафика клиентов на новый `Active` (использование `pgbouncer`).

**Проблема:**

Во всех режимах работы при разрыве сети между ЦОДами и недоступностью `Active` велика вероятность потери данных в результате `Split Brain`.

**Рекомендации:**

-   добавление в схему новых элементов: `pgbouncer` и `confd`.
